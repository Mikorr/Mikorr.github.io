<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTML是什么</title>
    <url>/2018/09/04/test/</url>
    <content><![CDATA[<h2 id="HTML是什么"><a href="#HTML是什么" class="headerlink" title="HTML是什么"></a>HTML是什么</h2><p>HTML指的是超文本标记语言 是制作超级文本文档的简单标记语言 可以从一个平台移    植到另一个平台 通常用于制作网页 html文件时asci文本 包括格式标记和超级文本链    的嵌入代码</p>
<p>HTMLtext是由HTML命令组成的描述性文本 他能够描述文字 图形 动画 声音 表格     连接等 网页结构由标题和正文两部分组成 Header描述浏览器需要的信息 并且主体    包含要描述的具体内容</p>
<p>Html是网页设计的基础。在网站结构中，静态网页被称为基于 HTML的网页。过去的网页都是直接用 HTML代码编写的，但现在有许多智能网页制作软件(经常使用的 frontpage、 dream weaver等)通常都是通过这些软件自动生成的，而不是手工编写。虽然不一定要自己写，但是理解 HTML代码还是很重要的。了解 HTML是什么？了解网站建设的重要技术基础知识。</p>
<h2 id="浏览器内核-常见的浏览器内核"><a href="#浏览器内核-常见的浏览器内核" class="headerlink" title="浏览器内核 常见的浏览器内核"></a>浏览器内核 常见的浏览器内核</h2><p>浏览器内核主要分为两部分：渲染引擎和JS引擎</p>
<p>渲染引擎：负责去的网页的内容(HTML、XML、图像等等) 整理讯息(例如加入css等) 以              及计算网页的思显示方式 然后会输出至服务器或打印机 浏览器的内核的              不同对于网页的语法解释会有不同 所以渲染的结果也不相同 所有网页浏              览器 电子邮件客户端以及其他需要编辑 显示网络内容的应用程序都需要              内核</p>
<p>JS引擎：解析和执行js来实现网页的动态效果</p>
<p>最开始渲染引擎和js引擎并没有区分的很明确 后来JS引擎越来越独立 内核就倾向于    只指渲染引擎</p>
<p>常见的浏览器内核：</p>
<p>IE浏览器内核:Trident内核 也是俗称的IE内核</p>
<p>Chrome浏览器内核:统称为Chromium内核或Chrome内核 以前是Webkit内核 现                      在是Blink内核</p>
<p>Firefox浏览器内核:Gecko内核 统称Firefox内核</p>
<p>Safari浏览器内核:Webkit内核</p>
<p>Opera浏览器内核:最初是自己的Presto内核 后来是Webkit 现在是Blink内核</p>
<p>360浏览器 猎豹浏览器内核:IE+Chrome双内核</p>
<p>搜狗 遨游 QQ浏览器内核:Trident+Webkit</p>
<p>百度浏览器内核:IE内核</p>
<p>2345浏览器内核:以前是IE内核 现在是IE+Chrome双内核</p>
<h2 id="如何理解HTML语义化"><a href="#如何理解HTML语义化" class="headerlink" title="如何理解HTML语义化"></a>如何理解HTML语义化</h2><p>用正确的标签做正确的事情</p>
<p>HTML语义化就是让页面的内容结构化 便于对浏览器 搜索引擎解析</p>
<p>在没有样式css情况下也以一种文档格式显示 并且是容易阅读的</p>
<p>搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重 利于SEO</p>
<p>使阅读源代码的人对网站更容易将网站分块 便于阅读维护理解</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>块标签 行内标签 行内块标签 区别？ 常见的标签？</title>
    <url>/2018/09/04/block/</url>
    <content><![CDATA[<p>行内标签 inline 又叫内联标签：<br>特点：不独占一行 每个行标签元素并排排序 直到遇到父级边界换行<br>不支持宽高 内容文本撑开宽高 不支持上下外边距 但支持左右外边距<br>会不正常显示上下内边距 不建议设置内边距<br>行内标签通常用于配合p标签实现富文本 富文本是指在一行文字中 文字形式不    统一<br>常见行内标签:</p>
<p>&lt;a&gt; &lt;span&gt;&lt;i&gt; &lt;b&gt; &lt;sub&gt; &lt;sup&gt; &lt;em&gt; &lt;strong&gt;&lt;br&gt;<br>块标签：<br>特点：独占一行 默认宽度占满父级 默认高度为0 子级内容撑开高度<br>常见块标签</p>
<p>&lt;h1-h6&gt;&lt;div&gt; &lt;p&gt; &lt;ul&gt; &lt;ol&gt;&lt;li&gt;&lt;dl&gt;&lt;dd&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;hr&gt; &lt;article&gt;<br>行内块标签：<br>特点：不独占一行 可以设置宽高<br>常见行内块标签：</p>
<p>&lt;img&gt; &lt;input&gt; &lt;textarea&gt; &lt;select&gt; &lt;option&gt;</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的浏览器内核</title>
    <url>/2018/09/05/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<h2 id="浏览器内核-常见的浏览器内核"><a href="#浏览器内核-常见的浏览器内核" class="headerlink" title="浏览器内核 常见的浏览器内核"></a>浏览器内核 常见的浏览器内核</h2><p>浏览器内核主要分为两部分：渲染引擎和JS引擎</p>
<p>渲染引擎：负责去的网页的内容(HTML、XML、图像等等) 整理讯息(例如加入css等) 以              及计算网页的思显示方式 然后会输出至服务器或打印机 浏览器的内核的              不同对于网页的语法解释会有不同 所以渲染的结果也不相同 所有网页浏              览器 电子邮件客户端以及其他需要编辑 显示网络内容的应用程序都需要              内核</p>
<p>JS引擎：解析和执行js来实现网页的动态效果</p>
<p>最开始渲染引擎和js引擎并没有区分的很明确 后来JS引擎越来越独立 内核就倾向于    只指渲染引擎</p>
<p>常见的浏览器内核：</p>
<p>IE浏览器内核:Trident内核 也是俗称的IE内核</p>
<p>Chrome浏览器内核:统称为Chromium内核或Chrome内核 以前是Webkit内核 现                      在是Blink内核</p>
<p>Firefox浏览器内核:Gecko内核 统称Firefox内核</p>
<p>Safari浏览器内核:Webkit内核</p>
<p>Opera浏览器内核:最初是自己的Presto内核 后来是Webkit 现在是Blink内核</p>
<p>360浏览器 猎豹浏览器内核:IE+Chrome双内核</p>
<p>搜狗 遨游 QQ浏览器内核:Trident+Webkit</p>
<p>百度浏览器内核:IE内核</p>
<p>2345浏览器内核:以前是IE内核 现在是IE+Chrome双内核</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5有哪些新特性 移除了哪些元素？</title>
    <url>/2018/09/05/%E7%A7%BB%E9%99%A4%E4%BA%86%E5%93%AA%E4%BA%9B%E5%85%83%E7%B4%A0%EF%BC%9F/</url>
    <content><![CDATA[<p>HTML现在已经不是SGML的子集 主要是关于图像 位置 存储 多任务等功能的增加</p>
<p>新增选择器document.querySelector document.querySelectorAll</p>
<p>拖拽播放(Drag and drop) API</p>
<p>媒体播放的video和audio</p>
<p>本地存储localStorage和sessionStorage</p>
<p>离线应用manifest</p>
<p>桌面通知Notifications</p>
<p>语义化标签article footer header nav section</p>
<p>增强表单控件 calendar date time email url search</p>
<p>地理位置 Geolocation</p>
<p>多任务 webworker</p>
<p>全双工通信协议 websocket</p>
<p>历史管理 history</p>
<p>跨域资源共享(CORS) Access-Control-Allow-Origin</p>
<p>页面可见性改变事件 visibilitychange</p>
<p>跨窗口通信 PostMessage</p>
<p>Form Data对象</p>
<p>绘画 canvas</p>
<p>移除的元素：</p>
<p>纯表现的元素：basefont big center font s strike tt u</p>
<p>对可见性产生负面影响的元素 frame frameset noframes</p>
<p>支持HTML5新标签：</p>
<p>IE8/IE7/IE6支持通过document.createElement方法产生的标签</p>
<p>可以利用这一特性让这些浏览器支持HTML5新标签</p>
<p>浏览器支持新标签后 还需要添加标签默认的样式</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用的命令有哪些</title>
    <url>/2018/10/13/Git%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B/</url>
    <content><![CDATA[<h2 id="Git常用的命令有哪些？"><a href="#Git常用的命令有哪些？" class="headerlink" title="Git常用的命令有哪些？"></a>Git常用的命令有哪些？</h2><p>git config –global user.name “用户名” </p>
<p>git config –global user.email “登录邮箱”</p>
<p>git clone url 下载一个项目和整个代码历史</p>
<p>git init 初始化仓库 默认master分支</p>
<p>git add . 提交全部文件修改到暂存区</p>
<p>git diff 查看当前代码add后 会add哪些内容</p>
<p>git status 查看当前分支状态</p>
<p>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt; 拉取远程仓库的分支与本地当前分支合并</p>
<p>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 拉取远程仓库的分支与本地某                                                 个分支和合并</p>
<p>git commit -m “&lt;注释&gt;” 提交代码到本地仓库 并写提交注释</p>
<p>git commit -v 提交时显示所有diff信息</p>
<p>git checkout &lt;分支名&gt; 切换到本地某个分支</p>
<p>git branch -D &lt;分支名&gt; 删除本地某个分支</p>
<p>git branch 查看本地所有分支</p>
<p>git branch -r 查看远程所有分支</p>
<p>git branch -a 查看本地和远程所有分支</p>
<p>git merge &lt;分支名&gt; 合并分支</p>
<p>git push [remote] [branch] 上传本地指定分支到远程仓库</p>
<p>git push [remote] –force 强行推送当前分支到远程仓库 即使有冲突</p>
<p>git checkout [file] 恢复暂存区的指定文件到工作区</p>
<p>git checkout . 恢复暂存区的所有文件到工作区</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>对git的理解</title>
    <url>/2018/10/13/%E5%AF%B9git%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="对git的理解"><a href="#对git的理解" class="headerlink" title="对git的理解"></a>对git的理解</h2><p>git是一个分布式版本控制软件 最初目的是为更好的管理Linuv内核开发而设计</p>
<p>分布式版本控制系统的客户端并不止提取最新版本的文件快照 而是把代码仓库完整的    镜像下来</p>
<p>GitHub或者gitee实际就可以充当服务器角色 其是一个开源协作社区</p>
<p>当我们通过git init 创建或者git clone一个项目时 项目目录会隐藏一个.git子目录 其作    用是用来跟踪管理版本库的</p>
<p>工作状态对应 不用状态文件在git中处于不同的工作区域 主要分成四部分:</p>
<p>工作区:相当于本地写代码的区域</p>
<p>暂存区:暂存区是一个文件 保存了下次将提交的文件列表信息 一般在git仓库目           录中</p>
<p>本地仓库:提交更新 找到暂存区域的文件 将快照永久性存储到Git本地仓库</p>
<p>远程仓库:远程的仓库 如GitHub gitee</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>浅拷贝和深拷贝的区别</title>
    <url>/2018/09/13/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="浅拷贝和深拷贝的区别"><a href="#浅拷贝和深拷贝的区别" class="headerlink" title="浅拷贝和深拷贝的区别"></a>浅拷贝和深拷贝的区别</h2><p>浅拷贝：主要是对指针的拷贝 拷贝后两个指针指向同一个内存空间 拷贝之后的数据修改之后 也会影响到原数据中的对象数据</p>
<p>深拷贝：将数据中所有的数据拷贝下来 对拷贝之后的数据进行修改不会影响到原数据</p>
<p>实现方式：</p>
<p>深拷贝：</p>
<p>1.使用递归实现</p>
<p>2.Json.stringify和Json.parse</p>
<p>用json.stringify把对象转换成字符串 再用Json.parse把字符串转换成新    的对象 可以转成Json格式的对象才能使用这种方法 如果对象中包含    function或RegExp就不能使用这种方法</p>
<ol>
<li>函数库lodash的_.cloneDeep方法</li>
</ol>
<p>var _ = require(‘loadsh’)</p>
<p>var obj = {</p>
<p>a:{</p>
<p>c:2,</p>
<p>d:[9,8,7]</p>
<p>},</p>
<p>b:4</p>
<p>}</p>
<p>var obj1 = _.cloneDeep(obj)</p>
<ol start="2">
<li>通过JQuery的extend方法实现深拷贝：</li>
</ol>
<p>var _ = require(‘jquery’)</p>
<p>var obj = {</p>
<p>a:{</p>
<p>c:2,</p>
<p>d:[9,8,7]</p>
<p>},</p>
<p>b:4</p>
<p>}</p>
<p>var obj1 = _.extend(true,{},obj)</p>
<p>浅拷贝：</p>
<ol>
<li>通过拷贝构造方法实现浅拷贝：</li>
</ol>
<p>拷贝构造方法指的是该类的构造方法参数为该类的对象 使用拷贝构造方    法可以很好地完成浅拷贝 直接通过一个现有的对象创建出与该对象属性    相同的新对象</p>
<ol start="2">
<li>通过重写clone()方法进行浅拷贝</li>
</ol>
<p>object类有一个方法为protected Object clone() throws     CloneNotSupportedException 这个方法就是进行的浅拷贝 有了这个浅拷    贝模板 可以通过调用clone()方法来实现对象的浅拷贝</p>
<p>​    注意：</p>
<p>​    object类虽然有这个方法 但是这个方法是受保护的 所以无法直接使用</p>
<p>​    使用clone方法的类必须实现Cloneable接口 否则会抛出异常    CloneNotSupportedException 解决方法是 在使    用clone方法的类中重写clone方法 通过super.clone()调用object类中的原clone方法</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>说说git发生冲突的场景</title>
    <url>/2018/10/14/%E8%AF%B4%E8%AF%B4git%E5%8F%91%E7%94%9F%E5%86%B2%E7%AA%81%E7%9A%84%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h2 id="说说git发生冲突的场景"><a href="#说说git发生冲突的场景" class="headerlink" title="说说git发生冲突的场景"></a>说说git发生冲突的场景</h2><p>情景一：多个分支代码合并到一个分支</p>
<p>情景二：多个分支向同一个远端分支推送代码时</p>
<p>push和pull其实就是分别用本地分支合并到远程分支和将远程分支合并到本地分支</p>
<p>所以这两个过程中也可能存在冲突</p>
<p>git的合并产生冲突的具体情况：</p>
<p>1 两个分支中修改了同一个文件</p>
<p>2 两个分支中修改了同一个文件的名称</p>
<p>两个分支中分别修改了不同文件中的部分 不会产生冲突 可以直接将两部分合并</p>
<p>解决方法：</p>
<p>情景一：在当前分支 直接修改冲突代码</p>
<p>情景二：在本地当前分支 修改冲突代码</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的数据类型 存储上的区别</title>
    <url>/2018/10/23/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="JavaScript中的数据类型-存储上的区别"><a href="#JavaScript中的数据类型-存储上的区别" class="headerlink" title="JavaScript中的数据类型 存储上的区别"></a>JavaScript中的数据类型 存储上的区别</h2><p>基本数据类型：</p>
<p>Number</p>
<p>String</p>
<p>Boolean</p>
<p>Undefined</p>
<p>Null</p>
<p>Symbol</p>
<p>引用数据类型：</p>
<p>Object</p>
<p>Array</p>
<p>Function</p>
<p>区别：</p>
<p>基本数据类型指的就是简单的数据段 引用数据类型指的是多个值构成的对象 当    我们把变量赋值给一个变量时 解析器首先要确认的就是这个值是基本数据类型还    是引用类型值</p>
<p>存储区别：</p>
<p>Js中的变量都是保存在栈内存中的 基本数据类型的值都是直接保存在栈内存中     值与值之间是独立的存在 因此当修改一个变量的值不会影响其他变量的值</p>
<p>对象是保存在堆内存中的 每创建一个对象 就会在堆内存中开辟出一个新的空间     变量保存的是对象的内存地址（对象的应用） 保存的并不是值 如果两个变量保存    的是同一个地址 当通过一个变量修改属性时 另一个也会受影响</p>
<p>比较两个基本数据类型的值时 比较的就是值 比较两个引用数据类型时 比较的是内存地址 如果两个对象一模一样但是内存地址不同 也会返回false</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>对闭包的理解</title>
    <url>/2018/11/01/%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="对闭包的理解"><a href="#对闭包的理解" class="headerlink" title="对闭包的理解"></a>对闭包的理解</h2><p>闭包就是能够读取其他函数内部变量的函数</p>
<p>闭包指有权访问另一个函数作用域中变量的函数 创建闭包最常见的方式就是在一个函    数内创建另一个函数 通过另一个函数访问这个函数的局部变量</p>
<p>闭包特性：</p>
<p>函数套函数</p>
<p>内部函数可以引用外部函数的参数和变量</p>
<p>不会被垃圾回收机制回收    </p>
<p>使用闭包主要是为了设计私有方法和变量 闭包的优点是可以避免全局变量污染 缺点    是闭包会常驻内存 增大内存使用量 使用不当容易造成内存泄漏 在js中 函数即闭包</p>
<p>闭包最大的用处 一是可以读取函数内部变量 二是让这些变量始终保持在内存中 延长    变量生命周期</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是模块化</title>
    <url>/2018/10/21/%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h2><p>模块化指解决一个复杂问题时 自顶向下逐层把系统划分成若干模块的过程 对于整体    系统来说 模块是可组合 分解和更换的单元</p>
<p>一个js文件中可以引入另一个js文件的数据</p>
<p>模块化的好处：</p>
<p>提高了代码的复用性</p>
<p>提高了代码的可维护性</p>
<p>可以实现按需加载</p>
<p>模块化的规范：</p>
<p>每个模块内部 module变量代表当前模块</p>
<p>module变量是一个对象 他的exports是对外的接口</p>
<p>加载某个模块 其实是加载该模块的module.exports属性 .require()方法常用于加载    模块</p>
<p>在自定义模块中定义的变量和方法 只能在当前模块被访问 外部文件不可访问 这种模    块级别的访问限制 叫做模块作用域 他防止了全局变量污染 文件依赖等问题</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>typeof与instanceof区别</title>
    <url>/2018/11/04/typeof%E4%B8%8Einstanceof%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="typeof和instanceof的区别"><a href="#typeof和instanceof的区别" class="headerlink" title="typeof和instanceof的区别"></a>typeof和instanceof的区别</h2><p>typeof操作符返回一个字符串 表示未经计算的操作数的类型</p>
<p>null在typeof之后返回的是有问题的结果 不能作为判断null的方法 判断null array object和函数实例 都是返回object 引用数据类型    使用typeof判断 除了function可以被识别 其余都输出object</p>
<p>instanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型    链上 </p>
<p>区别：</p>
<p>typeof返回一个变量基本类型 instanceof返回一个布尔值</p>
<p>instanceof可以准确判断复杂引用数据类型  但不能正确判断基础数据类型</p>
<p>typeof虽然可以判断基础数据类型 但是引用数据类型中 除了function类型 其他    的也无法判断    </p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>css选择器</title>
    <url>/2018/10/02/css%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器"></a>css选择器</h2><p>css选择器是css规则的一部分  是元素和其他部分组合起来告诉浏览器哪个html元素应当是被选为应用规则中的css属性值的方式 选择器所选择的元素 叫做选择器的对象</p>
<p>Css选择器常用的有：</p>
<p>Id选择器(#box) 选择id为box的元素</p>
<p>类选择器(.box) 选择类名为box的所有元素</p>
<p>标签选择器(div) 选择标签为div的所有元素</p>
<p>后代选择器(#box div) 选择id为box元素内部所有div元素</p>
<p>子选择器(.box&gt;box_1) 选择父元素类名为box内所有类名为box_1的元素</p>
<p>相邻同胞选择器(.one+.two) 选择紧接在.one之后的所有.two元素</p>
<p>群组选择器(div,p) 选择所有div p元素</p>
<p>还有一些使用频率相对没那么多的选择器:</p>
<p>伪类选择器:</p>
<p>:link:选择未被访问的链接</p>
<p>:visited:选择已被访问的链接</p>
<p>:active:选择活动链接</p>
<p>:hover:鼠标指针浮动在上面的元素</p>
<p>:focus:算则具有焦点的</p>
<p>:first-child:父元素的首个子元素</p>
<p>伪元素选择器:</p>
<p>:first-letter:用于选区制定选择器的首字母</p>
<p>:first-line:选取指定选择器的首行</p>
<p>:before:选择器在被选元素的内容前面插入内容</p>
<p>:after:选择器在被选元素的内容后面插入内容</p>
<p>属性选择器:</p>
<p>[attribute] 选择带有attribute属性的元素</p>
<p>[attribute=value] 选择所有使用attribute=value的元素</p>
<p>[attribute~=value] 选择attribute属性包含value的元素</p>
<p>[attribute|=value] 选择attribute属性以value开头的元素</p>
<p>在css3中新增的选择器有：</p>
<p>层次选择器(p~ul) 选择前面有p元素的每个ul元素</p>
<p>伪类选择器:</p>
<p>:first-of-type 父元素的首个元素</p>
<p>:last-of-type 父元素的最后一个元素</p>
<p>:only-of-type 父元素的特定类型的唯一子元素</p>
<p>:only-child 父元素中唯一子元素</p>
<p>:nth-child(n) 选择父元素中第N个子元素</p>
<p>:nth-last-of-type(n) 选择父元素中第N个子元素，从后往前</p>
<p>:last-child 父元素的最后一个元素</p>
<p>:root 设置HTML文档</p>
<p>:empty 指定空的元素</p>
<p>:enabled 选择被禁用元素</p>
<p>:disabled 选择被禁用元素</p>
<p>:checked 选择选中的元素</p>
<p>:not(selector) 选择非 <selector> 元素的所有元素</p>
<p>属性选择器:</p>
<p>[attribute*=value] :选择attribute属性值包含value的所有元素</p>
<p>优先级：内联样式&gt;ID选择器&gt;类选择器&gt;标签选择器</p>
<p>继承属性：</p>
<p>在css中 继承指的是给父元素设置一些属性 后代元素会自动拥有这些属性</p>
<p>继承属性可以分成：</p>
<p>字体系列属性:</p>
<p>font:组合字体</p>
<p>font-family:规定元素的字体系列</p>
<p>font-weight:设置字体的粗细</p>
<p>font-size:设置字体的尺寸</p>
<p>font-style:定义字体的风格</p>
<p>font-variant:偏大或偏小字体</p>
<p>文本系列属性:</p>
<p>Text-indent:文本缩进</p>
<p>Text-align:文本水平</p>
<p>Line-height:行高</p>
<p>word-spacing:增加或减少单词间的空白</p>
<p>letter-spacing:增加或减少字符间的空白</p>
<p>text-transform:控制文本大小写</p>
<p>direction:规定文本的书写方向</p>
<p>color:文本颜色</p>
<p>元素可见性:</p>
<p>visibility</p>
<p>表格布局属性:</p>
<p>caption-side:定义表格标题位置</p>
<p>border-collapse:合并表格边框</p>
<p>border-spacing:设置相邻单元格的边框间的距离</p>
<p>empty-cells:单元格的边框出现与消失</p>
<p>table-layout:表格的宽度由什么决定</p>
<p>列表属性:</p>
<p>list-style-type:文字前面的小点样式</p>
<p>list-style-position:小点位置</p>
<p>list-style:以上的属性可通过属性集合</p>
<p>引用:</p>
<p>quotes:设置嵌套引用的引号类型</p>
<p>光标属性:</p>
<p>cursor:箭头可以变成需要的形状</p>
<p>继承中比较特殊的几点:</p>
<p>h1-h6标签字体的大小也是不能被继承的</p>
<p>a标签字体颜色不能被继承</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>对盒子模型的理解</title>
    <url>/2018/10/02/%E5%AF%B9%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="对盒子模型的理解"><a href="#对盒子模型的理解" class="headerlink" title="对盒子模型的理解"></a>对盒子模型的理解</h2><p>在浏览网站时 我们会发现页面内容都是按照区域划分的 在页面中每一块区域分别承    载不同的内容 使网页内容虽然零散 但是在版式排列上依然清晰有条理 承载内容的区    域被称为盒子模型</p>
<p>盒子模型分为两种：</p>
<p>\1. 标准盒模型：content(内容)+margin(外边距)+padding(内边距)+border(边框)</p>
<p>\2. IE盒模型(怪异盒模型):content+margin</p>
<p>标准盒模型下的宽：盒子总宽度/高度=width/height+padding+border+margin 这种模    型下 写得元素往往会必设置的宽高要多出一部分padding border margin</p>
<p>IE盒模型下的宽:盒子总宽度和高度是包含内边距padding和变宽border宽度在内    的盒子总宽度/高度 = width/height+margin=内容区宽度/高度    +padding+border+margin 也就是说width = 内容区宽度+padding+border</p>
<p>我们在开发中往往使用IE盒模型 只需要设置box-sizing:border-box即可</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>元素水平垂直居中的方法</title>
    <url>/2018/10/05/%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="元素水平垂直居中的方法"><a href="#元素水平垂直居中的方法" class="headerlink" title="元素水平垂直居中的方法"></a>元素水平垂直居中的方法</h2><p>利用定位+margin:auto  </p>
<p>父级设置为相对定位 子级绝对定位 并且四个定位属性值都为0 如果子级没    有设置宽高 则会被拉开到和父级一样宽高 设置了宽高所以宽高会按照设置    来显示 实际上子级虚拟占位已经撑满了整个父级 再给他一个margin:auto就    可以垂直居中了</p>
<p>利用定位+margin:负值 </p>
<p>这种方案不要求父元素的高度 即使父元素的高度变化了 仍然可以保持在父    元素的垂直居中位置 水平方向上操作一样  但是该方案需要知道子元素自身    宽高</p>
<p>利用定位+transform</p>
<p>translate(-50%,-50%)将会将元素位移自己宽度和高度的-50%</p>
<p>这种方法其实和最上面被否定掉的margin负值用法一样 可以说是margin负    值的替代方案 并不需要知道自身元素的宽高</p>
<p>table布局</p>
<p>设置父元素为display:table-cell 子元素设置display:inline-block 利用vertical和    text-align可以让所有的行内块级元素水平垂直居中</p>
<p>flex布局</p>
<p>display:flex时 表示该容器内部的元素按照flex进行布局</p>
<p>Align-items:center表示这些元素将相对于本容器水平居中</p>
<p>justify-content:conter也是同样的道理垂直居中</p>
<p>grid布局</p>
<p>父级设置grid align-items:center justify-content:center 和flex相同</p>
<p>不知道元素宽高大小仍能实现水平居中的方法有：</p>
<p>利用定位+margin:auto</p>
<p>利用定位+transform</p>
<p>利用定位+margin:负值</p>
<p>flex布局</p>
<p>grid布局</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS提高性能的方法</title>
    <url>/2018/10/06/CSS%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>加载性能：</p>
<ol>
<li>css压缩：</li>
</ol>
<p>将写好的css进行打包 可以减少很多的体积</p>
<ol start="2">
<li>css单一样式：</li>
</ol>
<p>在需要下边距和左边距的时候 很多时候选择：margin:top 0 bottom 0 但是margin-bottom:bottom margin-left:left执行效率更高</p>
<ol start="3">
<li>减少@import建议使用link：</li>
</ol>
<p>因为link在页面加载时一起加载  @import是等待页面加载完成之后再进行加载</p>
<p>选择器性能：</p>
<p>​    1. 关键选择器：</p>
<p>选择器的最后面的部分为关键选择器 css选择器是从右向左进行匹配的 当使用后代选择器的时候 浏览器会遍历所有子元素来确定是否是指定的元素等等</p>
<p>​    2. 如果规则拥有ID选择器作为关键选择器：</p>
<p>不要为规则增加标签 过滤掉无关规则</p>
<p>​    3. 避免使用通配符规则：</p>
<p>如果*{} 计算次数太多 只对需要用到的元素进行选择</p>
<p>​    4. 尽量少的对标签选择 使用class</p>
<p>​    5. 了解哪些属性可以通过继承而来 避免对这些属性重复指定规则</p>
<p>渲染性能：</p>
<p>​    1. 慎重使用高性能属性：浮动 定位</p>
<p>​    2. 尽量减少页面的重排和重绘</p>
<p>​    3. 去除空规则,{}空规则的产生的原因一般是为了预留样式 去除空规则能减少css文档体积</p>
<p>​    4. 属性值为0时 不加单位</p>
<p>​    5. 属性值为浮动小数 可以省略小数点之前的0</p>
<p>​    6. 标准化各种浏览器前缀 带浏览器前缀的在前 标准属性在后</p>
<p>​    7. 不使用@import前缀 因为它会影响css的加载速度</p>
<p>​    8. 选择器优先嵌套 尽量避免层级过深</p>
<p>​    9. css雪碧图：</p>
<p>​        同一页面相近部分的小图标 方便实用 减少页面请求次数</p>
<ol start="10">
<li>正确使用display属性 由于display的使用 某一些样式组合会无效 徒增样式体积的同时也影响性能</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>事件循环</title>
    <url>/2018/11/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>Js是一门单线程的语言 同一时间内只能做一件事 每次只能执行一项任务 其他任务都得按照顺序排队等待被执行 只有当前任务执行完成之后才会执行下一个任务  任务分为同步任务和异步任务 异步任务永远在同步任务执行完成后才执行</p>
<p>注意：异步函数在响应辅助线程中处理完成后 即异步函数达到触发条件了 就把回调函数推入任务队列中 而不是说注册一个异步任务就会被放在任务队列中</p>
<p>主线程不断从任务队列中读取事件  这个过程是循环不断的 这种运行机制就叫做事件循环</p>
<p>事件循环中的两种任务：</p>
<p>在js中 除了广义的同步任务和异步任务 异步任务还可以细分 一种是宏任务(MacroTask) 一种是微任务(MicroTask)</p>
<p>每次单个宏任务执行完毕后 检查微任务队列是否为空 如果不为空 会按照先入先出的规则全部执行完微任务后 清空微任务队列 然后再执行下一个宏任务 依次循环</p>
<p>如何区分微任务 宏任务？</p>
<p>宏任务：macrotask可以理解为每次执行栈执行的代码就是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行) 一般包括script setTimeout     setInterval setImmediate IO操作</p>
<p>微任务：microtask 又称为job 可以理解是当前task执行结束后立即执行的任务 包括promise then cath finally回调 mutationObserver回调</p>
<p>为什么异步要区分宏任务与微任务？</p>
<p>因为事件队列其实是一个先进先出的数据结构 排在前面的事件会优先被主线程读取 如果突然来了一个优先级更高的任务 还排队就很不理性化 所以需要引入微任务</p>
<p>在当前微任务没有执行完成时 不会执行下一次宏任务的</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>响应式设计</title>
    <url>/2018/10/05/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>响应式设计是一种网络页面设计布局 页面的设计与开发应当根据用户行为以及设备环境(系统平台.屏幕尺寸.屏幕定向等)进行相应的响应和调整</p>
<p>响应式网站常见特点：同时适配PC+平板+手机等</p>
<p>标签导航在接近手持终端设备时改变为经典的抽屉式导航</p>
<p>网站的布局会根据视口来调整模块的大小和位置</p>
<p>实现方式：响应式设计的基本原理就是通过媒体查询检测不同设备屏幕尺寸做处理为了处理移动端 页面头部必须有meta声明viewport</p>
<p>&lt;meta name=”viewport” content=”width=device-width, initial-scale=1,     maximum-scale=1, user-scalable=no”&gt;</p>
<p>属性对应：</p>
<p>width=device-width:自适应手机屏幕的尺寸宽度</p>
<p>maximum-scale:缩放比例的最大值</p>
<p>Inital-scale:缩放的初始化</p>
<p>User-scalable:用户可以缩放的操作</p>
<p>实现响应式布局的方式：</p>
<p>媒体查询</p>
<p>Css3中增加了更多的媒体查询 就像if条件表达式一样 可以设置不同类型的媒体条件 并根据对应的条件给响应符合条件的媒体调用相对应的样    式表 使用@Media查询 可以针对不同的媒体类型定义不同的样式</p>
<p>当重置浏览器大小的过程中 页面也会根据浏览器的宽度和高度重新渲染页面</p>
<p>语法规范：</p>
<p>@media mediatype and|not|only (media feature){</p>
<p>css-code;</p>
<p>}</p>
<p>用@media开通</p>
<p>mediatype媒体类型</p>
<p>关键字and not only</p>
<p>media feature 媒体特性 必须有小括号包含</p>
<p>mediatype查询类型：将不同的终端设备划分为不同类型 称为媒体类型</p>
<table>
<thead>
<tr>
<th>值</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>用于所有设备</td>
</tr>
<tr>
<td>print</td>
<td>用于打印机和打印预览</td>
</tr>
<tr>
<td>scree</td>
<td>用于电脑屏幕 平板电脑 智能手机等</td>
</tr>
</tbody></table>
<p>关键字：将媒体类型或多个特性连接到一起作为媒体查询的条件</p>
<p>and:可以将多个媒体特性连接到一起 相当于且的意思</p>
<p>not:排除某个媒体类型 相当于非的意思 可以省略</p>
<p>only:指定某个特定的媒体类型 可省略</p>
<p>媒体特性：每种媒体类型都具备各自不同的特性 根据不同媒体类型特性设置不同的展示风格</p>
<table>
<thead>
<tr>
<th>值</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>定义输出设备中页面可见区域的宽度</td>
</tr>
<tr>
<td>min-width</td>
<td>定义输出设备中页面最小可见区域的宽度</td>
</tr>
<tr>
<td>max-width</td>
<td>定义输出设备中页面最大可见区域的宽度</td>
</tr>
</tbody></table>
<p>百分比</p>
<p>通过百分比单位%来实现响应式的效果 比如当浏览器宽度或高度发生变    化时 通过百分比单位 可以使得浏览器中的组件的宽和高随着浏览器的    变化而变化 从而实现响应式的效果 不能设置字体大小</p>
<p>vw/vh</p>
<p>vw表示相对于视图窗口的宽度 vh表示相对于视图窗口高度 任一层级元    素 在使用vw单位的情况下 1vw等于视图宽度的百分之一 1vh等于视图    高度的百分之一 与百分比    布局很相似 与百分比不同的是可以设置字体    大小 缺点兼容性较差</p>
<p>rem </p>
<p>rem相对于根元素html的font-size属性 默认情况下浏览器字体大小为    16px 可以利用媒体查询 针对不同设备分辨率修改font-size的值</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>回流和重绘</title>
    <url>/2018/10/05/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/</url>
    <content><![CDATA[<h2 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h2><p>回流：在渲染树构建完成 进入layout的时候 首先根据渲染树的数据 计算出各个节点在屏幕上的位置 然后进入绘制阶段渲染树中的一部分或者全部因为元素的规模尺寸 布局和隐藏等改变需要重新构建 这过程称为回流 每个页面至少需要一次回流 就是页面第一次加载的时候</p>
<p>重绘：渲染树中的一些元素需要更新属性 而这些属性只是影响元素的外观 风格 而不影响布局 称之为重绘</p>
<p>回流必定会引起重绘 因为回流将导致渲染树重新构建 回流花销比重绘花销高</p>
<p>重绘不一定引起回流</p>
<p>回流触发时机：</p>
<p>回流在一阶段主要是计算节点位置和几何信息 当页面布局和几何信息发生变化的时候 就需要回流：</p>
<p>添加或删除可见dom元素</p>
<p>元素位置发生变化</p>
<p>元素尺寸发生变化(包括外边距 内边距 边框大小 高度宽度等)</p>
<p>内容发生变化 比如文本变化或图片被另一个不同尺寸图片所替代</p>
<p>页面一开始渲染的时候</p>
<p>浏览器的窗口尺寸变化</p>
<p>还有通过即时计算得到的属性 浏览器为了获取这些值 也会进行回流</p>
<p>重绘触发时机：</p>
<p>触发回流一定会触发重绘</p>
<p>颜色的修改  文本方向修改  阴影的修改都会引发重绘</p>
<p>浏览器优化机制</p>
<p>由于每次重排都造成额外的计算消耗 因此大多数浏览器都会通过队列化修改并批量执行优化重排过程 浏览器会将修改操作放入到队列里 直到过了一段时间或者操作达到了一个阈值 才清空队列</p>
<p>当获取布局信息的操作时 会强制队列刷新</p>
<p>因此浏览器不得不清空队列 触发回流重绘返回正确的值</p>
<p>如何减少回流重绘</p>
<p>如果想设定元素样式 通过改变元素class类名</p>
<p>避免设置多项内联样式</p>
<p>应用元素的动画 使用position属性的fixed值或者absolute值</p>
<p>避免使用table布局 table每个元素大小以及内容改动会导致整个table重新计算</p>
<p>对于复杂的动画 对其设置position:fixed/absolute 尽可能使元素脱离文档流 从而减少对其他元素的影响</p>
<p>使用css3硬件加速 可以让transform opacity filters动画不会引起回流重绘</p>
<p>避免使用css的js表达式</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>BOM的理解</title>
    <url>/2018/09/21/BOM%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="BOM的理解"><a href="#BOM的理解" class="headerlink" title="BOM的理解"></a>BOM的理解</h2><p>BOM是浏览器对象模型 就是和浏览器有关系的 作用就是跟浏览器做交互效果</p>
<p>比如如何进行页面前进后退刷新 窗口发生变化 滚动条的滚动</p>
<p>浏览器全部内容可以看成DOM 整个浏览器可以看成BOM</p>
<p>BOM包含DOM</p>
<p>常用的BOM对象：</p>
<p>BOM的核心是window 表示浏览器的一个实例</p>
<p>在浏览器中 window对象有双重角色 即是浏览器窗口的一个接口 又是全局对象</p>
<p>因此所有在全局作用域中声明的变量函数都会变成window对象的属性和方法</p>
<p>document对象：文档对象</p>
<p>location对象：浏览器当前url信息  只要修改location的属性 就会导致页面重新加载新的URL</p>
<p>location.reload()可以重新刷新当前页面 这个方法会根据最有效的方    式刷新页面 如果页面自上一次请求以来没有改变过 页面就会从浏    览器缓存中重新加载 如果要强制从服务器中重新加载 穿第一个参数true即可</p>
<p>navigator对象：浏览器本身信息 主要用来获取浏览器的属性 区分浏览器类型</p>
<p>screen对象：客户端屏幕信息 保存的是客户端能力信息 就是浏览器窗口外面的客户端显示器的信息 比如像素宽度高度</p>
<p>history对象：浏览器访问历史信息 主要用来操作浏览器URL的历史记录 可以通过参数向前向后或者指定URL跳转</p>
<p>history.go() 接受一个整数数字或者字符串 像最近的一个记录中包含指定字符串的页面跳转</p>
<p>参数为整数数字时 正数表示向前跳转指定页面 负数为向后跳转指定页面</p>
<p>history.forward()向前跳转一个页面</p>
<p>history.back()向后跳转一个页面</p>
<p>history.length 获取历史记录数</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>bind、call、apply区别</title>
    <url>/2018/11/05/bind%E3%80%81call%E3%80%81apply%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="bind、call、apply区别"><a href="#bind、call、apply区别" class="headerlink" title="bind、call、apply区别"></a>bind、call、apply区别</h2><p>call apply bind作用是改变函数执行时的上下文 简而言之就是改变函数运行时的this指向</p>
<p>call和apply都是对函数进行直接调用 改变this指向后原函数会立即执行 且此方法只是临时改变this指向一次</p>
<p>而bind方法改变this指向不会立即执行 而是返回一个永久改变this指向的函数</p>
<p>三者第一个参数都是this指向的对象 如果没有这个参数或者参数为undefined或null 则默认指向全局window</p>
<p>三者都可以传参 但是apply是数组 call是参数列表 apply和call是一次性传入 bind可以分为多次传入</p>
<p>bind返回绑定this之后的函数 apply call是立即执行</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM常见的操作</title>
    <url>/2018/09/14/DOM%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="DOM常见的操作"><a href="#DOM常见的操作" class="headerlink" title="DOM常见的操作"></a>DOM常见的操作</h2><p>DOM 文档对象模式是html和XML文档的编程接口</p>
<p>提供了对文档结构化的表述 并定义了一种方式可以使从程序中对该结构进行访问     从而改变文档的结构样式和内容 任何HTML或XML文档都可以用DOM表示为一    个由节点构成的层级结构</p>
<p>获取节点：</p>
<p>document.getElementById(id) 通过id获取元素 返回一个元素对象</p>
<p>document.getElementByName(name) 通过name属性获取id返回元素对象数组</p>
<p>document.getElementByClassName(className) 通过class获取元素 返回元素    对象数组</p>
<p>document.getElementByTagName(tagName)  通过标签名获取元素 返回元素    对象数组</p>
<p>document.querySelector()  es6标准 通过css选择器获取元素 返回第一个匹    配元素 没有指定的元素返回null</p>
<p>document.querySelectorAll() es6标准 通过css选择器获取元素 返回类数组集    合 没有相匹配的返回空节点列表</p>
<p>获取/设置元素的属性值:</p>
<p>element.getArrtibute(attributeName) 括号传入属性名 返回对应属性的属性值</p>
<p>Element.setAttribute(attributeName,attributeValue) 传入属性名及设置的值</p>
<p>创建节点node：</p>
<p>document.createElement() 创建一个html元素 参数为要创建的标签名</p>
<p>document.createTextNode(string) 创建一个文本节点</p>
<p>Document.createDocumentFragment() 创建一个文档碎片 表示一种轻量级的    文档 主要用来存储临时节点 然后把文档碎片内容一次性添加到DOM中</p>
<p>document.createAttribute(class) 创建一个属性节点 可以是自定义属性</p>
<p>增添节点:</p>
<p>element.innerHTML 如果这个DOM节点是空的 直接使用innerHTML就可以修    改DOM节点的内容 相当于添加新的DOM节点</p>
<p>element.appendChild(Node) 往element内部最后面添加一个节点 参数是节点    类型</p>
<p>element.insertBefore(newNode,existingNode) 把子节点插入existingNode之前 </p>
<p>element.setArrtibute(‘class’,’white’) 在指定元素中添加一个属性节点 如果元素已有该属性    改变属性值 第一个参数为属性名 第二个参数为属性值</p>
<p>删除节点:</p>
<p>Element.removeChild(Node) 删除当前节点下指定的子节点 删除成功返回被    删除的节点 否组返回null</p>
<p>Element.removeAttribute(new,old)</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript本地存储的方式有哪些</title>
    <url>/2018/12/06/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B/</url>
    <content><![CDATA[<h2 id="Javascript本地存储的方式有哪些"><a href="#Javascript本地存储的方式有哪些" class="headerlink" title="Javascript本地存储的方式有哪些"></a>Javascript本地存储的方式有哪些</h2><p>在前端开发中 偶尔需要存储一些比如用户信息 登录状态 历史记录等常量数据 用于后续二次调用 避免刷新后丢失 就需要使用本地存储了</p>
<p>在JS中 提供了四种可用的本地存储</p>
<p>cookie</p>
<p>类型为小型文本文件 指某些网站为了辨别用户存储在用户本地终端上的数据 为了解决http无状态导致的问题</p>
<p>一般不超过4kb  由名称 值 和其他用于控制cookie有效期 安全性 适用范围的可选属性组成</p>
<p>Cookie在每次请求中都会被发送 如果不使用HTTPS加密 保存的信息很容易被窃取 导致安全风险</p>
<p>sessionStorage</p>
<p>与localStorage基本相同 唯一不同的是生命周期 一旦页面关闭 sessionStorage会删除数据</p>
<p>localStorage</p>
<p>生命周期：持久化的本地存储 除非主动删除 否则数据永远不会过期</p>
<p>存储的信息在同一域中共享</p>
<p>当本页操作了localStorage 本页面不会触发storage事件 别的页面会触发storage</p>
<p>大小在5MB左右</p>
<p>本质上是对字符串的读取 如果存储内容多的话消耗内存空间 导致页面变卡</p>
<p>受同源策略的限制</p>
<p>localStorage无法像cookie一样设置过期时间 </p>
<p>只能存入字符串 无法直接存入对象</p>
<p>indexedDB</p>
<p>是一种低级API 用于客户端存储大量机构化数据 该API使用索引实现对数据的高性能搜索</p>
<p>对于存储大量结构化数据来说 这种方法不太有用</p>
<p>优点：<br>        存储量理论上无上限</p>
<p>所有操作都是异步 相比localStorage同步操作性能更高 尤其数据量较大时</p>
<p>原生支持存储js对象</p>
<p>数据库能干的事情都能干</p>
<p>缺点：<br>        操作繁琐  本身有门槛</p>
<p>区别：<br>        存储大小：cookie数据大小不能超过4k sessionStorage和localStorage虽然也有限制 但是比cookie大得多 indexDB无上限</p>
<p>有效时间：localStorage存储持久数据  浏览器关闭后数据不丢失除非主动删除</p>
<p>sessionStorage数据在当前浏览器页面关闭后自动删除 cookie设置的cookie过期时间之前一直有效</p>
<p>数据与服务器之间交互：cookie数据自动传递到服务器 服务器端也可以写cookie到客户端</p>
<p>sessionStorage和localStorage不会自动把数据发给服务器 仅在本地保存</p>
<p>应用场景：</p>
<p>标记用户跟踪用户行为 推荐使用cookie</p>
<p>适合长期保存在本地的数据 推荐使用localStorage</p>
<p>敏感账号一次性登录 使用sessionStorage</p>
<p>存储大量数据 在线文档保存编辑历史 推荐使用indexedDB</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>new操作符</title>
    <url>/2019/01/16/new%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h2><p>在js中 new操作符用于创建一个给定构造函数的实例对象</p>
<p>new可以创建一个实例对象  对象是给定的构造函数</p>
<p>new通过构造函数创建出来的实例可以访问到构造函数中的属性</p>
<p>new通过构造函数创建出来的实例可以访问到构造函数原型链中的属性(即实例与构造函数通过原型链连接了起来)</p>
<p>构造函数返回一个原始值 返回值不会起到作用</p>
<p>构造函数返回一个对象 这个返回值会被正常使用</p>
<p>流程：<br>        创建一个新的对象obj</p>
<p>将对象与构造函数通过原型链连接起来</p>
<p>将构造函数中的this绑定到新建的对象上</p>
<p>根据构造函数返回类型判断 如果是原始值被忽略 如果是对象 需要正常处理</p>
<p>function create(fn,…args){</p>
<p>var obj = {}</p>
<p>Object.setPrototypeOf(obj,fn.prototype)</p>
<p>var result = fn.apply(obj,args)</p>
<p>return result instanceof Object ? result : obj</p>
<p>}</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>null，undefined的区别</title>
    <url>/2019/03/12/null%EF%BC%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>Undefined表示变量声明过但并未赋过值 他是所有未赋值变量默认值</p>
<p>null表示一个变量将来可能指向一个对象 一般用于主动释放指向对象的引用</p>
<p>null 表示为空 代表此处不应该有值的存在 一个对象可以是null 代表是一个空对象 null本身也是对象</p>
<p>Undefined表示不存在 js是一门动态类型语言 成员除了表示存在的空值外 还有可能根本就不存在</p>
<p>Null：<br>        用作函数的参数 表示该函数的参数不是对象</p>
<p>用作对象原型链的终点</p>
<p>undefined：</p>
<p>函数没有返回值 默认返回undefined</p>
<p>变量已声明未赋值 为undefined</p>
<p>对象中没有赋值的属性 值为undefined</p>
<p>调用函数时  应该提供的参数没有提供 参数等于undefined</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>this对象</title>
    <url>/2019/01/11/this%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h2><p>this是js中很常见的关键字 但是this在函数的不同执行环境内 所代表的是很灵活的</p>
<p>因此很难知道this代表什么 只有在函数运行后 才能知道它代表什么</p>
<p>在绝大多数情况下 函数的调用方式决定了this的值</p>
<p>This关键字是函数运行时自动生成的一个内部对象 只能在函数内部使用 总指向调用他的对象</p>
<p>将this分为严格模式下的this和非严格模式下的this</p>
<p>在严格模式下调用一个普通函数 this表示undefined</p>
<p>非严格模式下相同代码输出Window</p>
<p>非严格模式下：</p>
<p>如果this在普通函数中 this表示window 即普通函数调用 this表示window</p>
<p>在一个对象中 如果有方法 通过这个对象调用方法 方法中的this表示这个对象</p>
<p>在IIFE中 this也表示window</p>
<p>事件绑定 事件处理程序 事件发生时 浏览器帮我0们调用这个函数 this表示事件源</p>
<p>绑定规则：根据不同的使用场合 this有不同的值</p>
<p>默认绑定</p>
<p>全局环境中定义函数 内部使用this关键字 this指向window</p>
<p>隐式绑定</p>
<p>函数还可以作为某个对象的方法调用 this指的是上级对象</p>
<p>New绑定</p>
<p>通过构建函数new关键字生成一个实例对象 this指向实例对象</p>
<p>new过程遇到return对象 this指向为返回的对象</p>
<p>return的是简单类型 this指向实例对象</p>
<p>如果返回null null虽然也是对象 但是this仍然指向实例对象</p>
<p>显示修改</p>
<p>apply() call() bind()是函数的一个方法 作用是改变函数的调用对象 第一个参数就表示改变后的调用这个函数的对象 因此 this指的就是第一个参数</p>
<p>箭头函数：<br>    在es6语法中提供了箭头函数语法 让我们在代码书写时就能确定this的指向</p>
<p>当我们使用箭头函数的时候 箭头函数默认帮我们绑定外层this的值 所以在箭头函数中this的值和外层的this一样</p>
<p>箭头函数中的this引用的就是最近作用域的this</p>
<p>向外层作用域中一层一层查找this 直到有this的定义</p>
<p>有的箭头函数没有自己的this 不适合定义一个对象的方法</p>
<p>箭头函数不能作为构建函数</p>
<p>优先级：</p>
<p>new绑定优先级&gt;显示绑定优先级&gt;隐式绑定优先级&gt;默认绑定优先级</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>tree-shaking</title>
    <url>/2019/03/06/tree-shaking/</url>
    <content><![CDATA[<h2 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h2><p>Tree Shaking 指的就是当我引入一个模块的时候，我不引入这个模块的所有代码，我只引入我需要的代码，这就需要借助 webpack 里面自带的 Tree Shaking 这个功能来帮我们实现。</p>
<p>官方有标准的说法：Tree-shaking的本质是消除无用的js代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码，这个称之为DCE（dead code elimination）</p>
<p>在 webpack 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 Tree-Shaking，将没有使用的模块摇掉，这样来达到删除无用代码的目的。</p>
<p>在production 模式下不用在webpack.config.js中配置</p>
<p>optimization: {<br>usedExports: true</p>
<p>}<br>当在development模式下配置tree shaking时：<br>webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HtmlWebpackPlugin</span></span><br><span class="line"><span class="comment">//当我们整个打包过程结束的时候，自动生成一个html文件，</span></span><br><span class="line"><span class="comment">//并把打包生成的自动引入到html这个文件中；</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanWebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//打包模式，当为‘production’，打包后的文件会被压缩，</span></span><br><span class="line">    <span class="comment">//当为‘development’时打包后的文件不会被压缩,按照开发环境进行打包</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">//在开发者模式中SourceMap默认已经被配置在项目里了。</span></span><br><span class="line">    <span class="comment">// devtool: &#x27;none&#x27;, //关闭SourceMap</span></span><br><span class="line">    <span class="comment">//cheap：在生成SourceMap的时候，可以不带列信息，只带行信息,不要包含loader里面的SourceMap的生成，</span></span><br><span class="line">    <span class="comment">//只对业务代码进行SourceMap的生成</span></span><br><span class="line">    <span class="comment">//module:对loader里面的代码也进行一个SourceMap的生成</span></span><br><span class="line">    <span class="comment">//eval：eval是一种执行方式</span></span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&#x27;cheap-module-eval-source-map&#x27;</span>, <span class="comment">//打开SourceMap</span></span><br><span class="line">    <span class="comment">// devtool: &#x27;cheap-module-source-map&#x27;, //要线上的代码可以映射</span></span><br><span class="line">    <span class="comment">// 打包的入口文件</span></span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/index2.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// entry: &#123;</span></span><br><span class="line">    <span class="comment">//     main: &#x27;./src/index2.js&#x27;</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">contentBase</span>: <span class="string">&#x27;./dist&#x27;</span>, <span class="comment">//我们要在哪一个目录下去启动这个服务器</span></span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>, <span class="comment">//会自动的打开一个浏览器，然后自动访问服务器的地址（localhost:8080）</span></span><br><span class="line">        <span class="attr">hot</span>: <span class="literal">true</span>, <span class="comment">//指是否支持热更新（hmr）</span></span><br><span class="line">        <span class="attr">hotOnly</span>: <span class="literal">true</span>, <span class="comment">//即使不支持hmr或者hmr有问题,也不刷新浏览器</span></span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">                <span class="comment">//当访问localhost:8080/api的时，它会直接帮你转发到http://localhost:3000</span></span><br><span class="line">                <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">                <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [&#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">                <span class="attr">use</span>: &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="comment">//url-loader会把图片转化成一个base64的字符串，</span></span><br><span class="line">                        <span class="comment">//然后直接放到bundle.js里，而不是单独生成一个图片文件，</span></span><br><span class="line">                        <span class="comment">//好处：不用再额外的请求图片的地址，省了一次http请求；</span></span><br><span class="line">                        <span class="comment">//缺点：如果图片特别大过大，打包生成的js文件就会很大，</span></span><br><span class="line">                        <span class="comment">//那么加载js文件的时间就会很长，所以在一开始很长的时间里，页面上什么都显示不出来；</span></span><br><span class="line">                        <span class="comment">//所以，url-loader最佳的使用方式：加一个limit</span></span><br><span class="line">                        <span class="comment">//如果图片小于limit的值就把图片变为一个base64的字符串放到打包好的js中，</span></span><br><span class="line">                        <span class="comment">//若大于limit的值，就以file-loader的生成一个图片放到dist目录下。</span></span><br><span class="line">                        <span class="attr">limit</span>: <span class="number">8192</span>, <span class="comment">//好处是可以对小图片的http请求数减少，提升网页加载数度</span></span><br><span class="line">                        <span class="attr">name</span>: <span class="string">&#x27;images/[name].[hash].[ext]&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.(css|scss|less)$/</span>,</span><br><span class="line"> </span><br><span class="line">                <span class="comment">//&quot;css-loader&quot;:会帮我们分析出几个css文件之间的关系，最终把这些css文件合并成一段css;</span></span><br><span class="line">                <span class="comment">//&quot;style-loader&quot;:会把‘css-loader’生成的内容挂在到页面的head部分</span></span><br><span class="line">                <span class="comment">//在webpack的配置中，loader是有先后执行顺序的，</span></span><br><span class="line">                <span class="comment">//loader的执行顺序是从下到上，从右到左；</span></span><br><span class="line">                <span class="comment">//“sass-loader”会先对sass代码进行翻译，翻译为css代码后给到css-loader,</span></span><br><span class="line">                <span class="comment">//都处理好了之后再交给‘style-loader’挂在到页面上</span></span><br><span class="line">                <span class="comment">//postcss-loader会自动添加css3的厂商前缀；比如：  transform: translate(100px, 100px)</span></span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                        <span class="attr">options</span>: &#123;</span><br><span class="line">                            <span class="attr">importLoaders</span>: <span class="number">2</span>,</span><br><span class="line">                            <span class="attr">modules</span>: <span class="literal">true</span> <span class="comment">//使得css模块化，</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;sass-loader&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 可以打包字体文件</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.(eot|ttf|svg)$/</span>,</span><br><span class="line">                <span class="attr">use</span>: &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 打包的出口文件</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">// 打包后的文件名</span></span><br><span class="line">        <span class="comment">// filename: &#x27;bundle.js&#x27;,</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>, <span class="comment">//name就是entry值的key:&#x27;main&#x27;,&#x27;sub&#x27;</span></span><br><span class="line">        <span class="comment">// 打包后的文件目录为&#x27;dist&#x27;</span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">publicPath</span>: <span class="string">&#x27;/&#x27;</span> <span class="comment">//表示的是我所有的打包生成的文件之间的引用前面都加一个根路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//plugin可以在webpack运行到某个时刻的时候，帮你做一些事情(类似生命周期函数)</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="comment">// CleanWebpackPlugin可以在每次打包的时候帮我们对dist目录做一个清空</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">            <span class="comment">//HtmlWebpackPlugin帮我们自动的生成一个dist目录下的html文件</span></span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="comment">//HotModuleReplacementPlugin帮我们实现HMR</span></span><br><span class="line">        <span class="keyword">new</span> webpack.<span class="title class_">HotModuleReplacementPlugin</span>()</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">//在开发模式下配置 tree shakeing</span></span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">usedExports</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 package.json 中配置:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;webpack-demo&quot;</span>,</span><br><span class="line"><span class="comment">//@babel/polyfill和css文件不使用tree shaking</span></span><br><span class="line">    <span class="string">&quot;sideEffects&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;@babel/polyfill&quot;</span>,</span><br><span class="line">        <span class="string">&quot;*.css&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;bundle&quot;</span>: <span class="string">&quot;webpack&quot;</span>,</span><br><span class="line">        <span class="string">&quot;watch&quot;</span>: <span class="string">&quot;webpack --watch&quot;</span>,</span><br><span class="line">        <span class="string">&quot;start&quot;</span>: <span class="string">&quot;webpack-dev-server&quot;</span>,</span><br><span class="line">        <span class="string">&quot;server&quot;</span>: <span class="string">&quot;node server.js&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;author&quot;</span>: <span class="string">&quot;susie&quot;</span>,</span><br><span class="line">    <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">    <span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@babel/core&quot;</span>: <span class="string">&quot;^7.5.4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>: <span class="string">&quot;^7.5.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@babel/preset-env&quot;</span>: <span class="string">&quot;^7.5.4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@babel/preset-react&quot;</span>: <span class="string">&quot;^7.0.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;autoprefixer&quot;</span>: <span class="string">&quot;^9.6.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;babel-loader&quot;</span>: <span class="string">&quot;^8.0.6&quot;</span>,</span><br><span class="line">        <span class="string">&quot;clean-webpack-plugin&quot;</span>: <span class="string">&quot;^3.0.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;css-loader&quot;</span>: <span class="string">&quot;^3.0.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;file-loader&quot;</span>: <span class="string">&quot;^4.0.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;html-webpack-plugin&quot;</span>: <span class="string">&quot;^3.2.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;node-sass&quot;</span>: <span class="string">&quot;^4.12.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;postcss-loader&quot;</span>: <span class="string">&quot;^3.0.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sass-loader&quot;</span>: <span class="string">&quot;^7.1.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;style-loader&quot;</span>: <span class="string">&quot;^0.23.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;url-loader&quot;</span>: <span class="string">&quot;^2.0.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;webpack&quot;</span>: <span class="string">&quot;^4.35.3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;webpack-cli&quot;</span>: <span class="string">&quot;^3.3.5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;webpack-dev-server&quot;</span>: <span class="string">&quot;^3.7.2&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@babel/polyfill&quot;</span>: <span class="string">&quot;^7.4.4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@babel/runtime&quot;</span>: <span class="string">&quot;^7.5.4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@babel/runtime-corejs2&quot;</span>: <span class="string">&quot;^7.5.4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;react&quot;</span>: <span class="string">&quot;^16.8.6&quot;</span>,</span><br><span class="line">        <span class="string">&quot;react-dom&quot;</span>: <span class="string">&quot;^16.8.6&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果需要对某个模块不进行Tree Shaking</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;sideEffects&quot;</span>: [<span class="string">&quot;@babel/poly-fill&quot;</span>],  <span class="comment">//该模块不进行Tree Shaking</span></span><br></pre></td></tr></table></figure>

<p>为什么某些引入模块不希望进行Tree Shaking呢？</p>
<p>下面引入的style.css模块，如果也使用tree shaking，由于css文件没有导出任何模块，那么就有可能在打包的时候该引入模块就被摇晃掉了，导致bug。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./style.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;add&#125; <span class="keyword">from</span> <span class="string">&#x27;./math.js&#x27;</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>在package.json中进行配置，即匹配到的任何css文件都不进行Tree Shaking</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;lesson&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sideEffects&quot;</span>:[</span><br><span class="line">        <span class="string">&quot;*.css&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>事件代理</title>
    <url>/2018/01/09/%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><p>事件代理 又称之为事件委托 是js中绑定事件的常用技巧 顾名思义 事件代理即是把    原本需要绑定的事件委托给父元素 让父元素担当事件监听的职务 事件代理的原理是    DOM元素的事件冒泡 使用事件代理的好处是可以提高性能</p>
<p>可以大量节省内存占用 减少时间注册  比如在table上代理所有td的click事件</p>
<p>可以实现当新增子对象时无需再次对其绑定</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>原型和原型链</title>
    <url>/2019/01/06/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p>原型：</p>
<p>js规定 每个对象都有一个prototype对象属性 指向另一个对象 prototype的所有属性和方法  都会被构造函数的实例继承 我们可以把不变的属性和方法直接定义    在prototype对象属性上</p>
<p>prototype就是调用构造函数所创建的实例对象的原型</p>
<p>prototype可以让所有对象实例共享他所包含的属性和方法 不必在构造函数中定义对象信息 可以直接将这些信息添加到原型中</p>
<p>原型链：</p>
<p>实例对象与原型之间的连接 叫做原型链 proto<br>    原型对象也可能拥有原型 从中集成方法和属性 一层一层 依次类推 这种关系被称为原型链 它解释了为何一个对象会拥有定义在其他对象中的属性和方法</p>
<p>在对象实例和它的构造器之间建立一个链接(它是__proto__属性，是从构造函数的prototype属性派生的),之后通过上溯原型链 在构造器中找到这些属性和方法</p>
<p>一切对象都是继承自object对象 object对象直接继承根源对象null</p>
<p>一切的函数对象(包括object对象) 都是继承自Function对象</p>
<p>Object对象直接继承自Function对象</p>
<p>Function对象的__proto__会指向自己的原型对象 最终还是继承自object对象</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何通过JS判断一个数组</title>
    <url>/2018/12/27/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87JS%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="如何通过JS判断一个数组"><a href="#如何通过JS判断一个数组" class="headerlink" title="如何通过JS判断一个数组"></a>如何通过JS判断一个数组</h2><p>通过原型链判断：<br>        <strong>proto</strong> 实例的__proto__属性指向其构造函数的原型对象</p>
<p>const arr = [1,2,3]</p>
<p>arr.<strong>proto</strong> === Array.prototype</p>
<p>constructor 实例的constructor属性指向构造函数本身</p>
<p>arr.constructor ===Array</p>
<p>instanceOf 可以判断Array是否是实例的构造函数</p>
<p>arr instanceof Array</p>
<p>isPrototypeOf() 判断Array原型对象是否为在某个对象的原型链上</p>
<p>Array.prototype.isPrototypeOf(arr)</p>
<p>通过Object原型上的方法判断 </p>
<p>Array.isArray() es6用于判断数组类型的方法</p>
<p>Array.isArray(arr)</p>
<p>Object.prototype.toString 被所有对象继承 返回[Object type]字符串</p>
<p>Object.prototype.toString.call(arr)  </p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>对作用域链的理解</title>
    <url>/2018/11/16/%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="对作用域链的理解"><a href="#对作用域链的理解" class="headerlink" title="对作用域链的理解"></a>对作用域链的理解</h2><p>作用域：</p>
<p>即变量(变量作用域又称上下文)和函数生效的区域或集合</p>
<p>作用域决定了代码区块中变量和其他资源的可见性</p>
<p>在全局中无法获取到(闭包除外)函数内部的变量</p>
<p>一般将作用域分为：</p>
<p>全局作用域</p>
<p>任何不在函数中或者是大括号中声明的变量 都是在全局作用域下 全局    作用域下声明的变量可以在程序的任意位置访问</p>
<p>函数作用域</p>
<p>函数作用域也叫局部作用域 如果一个变量是在函数内部声明的它就在一    个函数作用域下面 这些变量只能在函数内部访问 不能再函数以外访问</p>
<p>块级作用域</p>
<p>ES6引入了let和const关键字 和var关键字不同 在大括号中使用let和    const声明的变量存在于块级作用域中 在大括号之外不能访问这些变量</p>
<p>词法作用域：<br>        又叫静态作用域 变量被创建时就确定好了 而非执行阶段确定 js遵循的就是词法        作用域</p>
<p>作用域链：<br>        当在js中使用一个变量的时候 首先js引擎会尝试在当前作用域下寻找该变量 如        果没找到 再到他的上层作用域寻找 以此类推直到找到该变量或已到了全局作用        域 如果在全局作用域仍找不到该变量 它就会在全局范围内隐式声明该变量或直        接报错</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖和节流</title>
    <url>/2018/12/15/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><p>本质上是优化高频率执行代码的手段</p>
<p>如：浏览器的resize scroll keypress mousemove等事件触发时 不断地调用绑定在事件上    的回调函数 极大地浪费资源 降低前端性能</p>
<p>为了优化体验 需要对这类事件进行调用次数的限制 我们可以采用防抖节流方式减少    调用频率</p>
<p>节流：n秒内只执行一次 若在n秒内重复触发 只有一次生效</p>
<p>防抖：n秒后在执行该事件 若在n秒内被重复触发 重新计时</p>
<p>区别：<br>        相同点：</p>
<p>都可以通过使用setTimeout实现</p>
<p>目的都是 降低回调执行频率 节省计算资源</p>
<p>不同点：</p>
<p>函数防抖 在一段连续操作结束后处理回调 利用clearTimeout和settimeout实    现 </p>
<p>函数节流 在一段连续操作中 每一段时间只执行一次 频率较高的事件中使用    来提高性能</p>
<p>防抖关注一定时间连续触发的事件 只在最后执行一次 节流一段时间内只执    行一次</p>
<p>应用场景：</p>
<p>防抖在连续的事件  只需触发一下次回调的场景：</p>
<p>搜索框搜索输入 只需用户最后一次输入完 在发送请求</p>
<p>手机号邮箱验证输入检测</p>
<p>窗口大小resize 只需窗口调整完成后 计算窗口大小 防止重复渲染</p>
<p>节流在间隔一段时间执行一次回调的场景：</p>
<p>滚动加载 加载更多或滚到底部监听</p>
<p>搜索框 搜索联想功能</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS数组和对象的遍历方式</title>
    <url>/2019/01/12/JS%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="JS数组和对象的遍历方式"><a href="#JS数组和对象的遍历方式" class="headerlink" title="JS数组和对象的遍历方式"></a>JS数组和对象的遍历方式</h2><p>for循环</p>
<p>for in 循环</p>
<p>forEach</p>
<p>这里的forEach回调中两个参数分别是value,index</p>
<p>forEach无法遍历对象</p>
<p>IE不支持该方法:Firefox和chrome支持</p>
<p>forEach无法使用break,continue跳出循环</p>
<p>这两汇总方法是非常常见且使用很频繁 实际上 两种方法都存在性能问题</p>
<p>for-in需要分析出array的每个属性 这个操作性能开销很大 用在key已知的数组上非常不划算 所以尽量不要用for-in 除非不清楚要处理哪些属性 例如JSON对象这样的情况</p>
<p>for循环每进行一次 就要检查一下数组长度 读取属性要比读局部变量慢 尤其当array存放的都是DOM元素 因为每次读取都会扫描一遍页面上的选择器相关元素 速度会大    大降低</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>XML和JSON的区别</title>
    <url>/2019/04/02/XML%E5%92%8CJSON%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="XML和JSON的区别"><a href="#XML和JSON的区别" class="headerlink" title="XML和JSON的区别"></a>XML和JSON的区别</h2><p>JSON是JavaScript Object Notation XML是可扩展标记语言</p>
<p>JSON是基于JavaScript语言 XML源自SGML</p>
<p>JSON是一种表示对象的方式 XML是一种标记语言 使用标记结构来表示数据项</p>
<p>JSON不提供对命名空间的任何支持 XML支持名称空间</p>
<p>JSON支持数组 XML不支持数组</p>
<p>XML文件相对难以阅读和解释 JSON文件非常易于阅读</p>
<p>JSON不适用结束标记 XML有开始结束标签</p>
<p>JSON安全性较低 XML比JSON更安全</p>
<p>JSON不支持注释 XML支持注释</p>
<p>JSON仅支持UTF-8编码 XML支持各种编码</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中常见的Plugin</title>
    <url>/2019/04/06/webpack%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84Plugin/</url>
    <content><![CDATA[<h2 id="webpack中常见的Plugin"><a href="#webpack中常见的Plugin" class="headerlink" title="webpack中常见的Plugin"></a>webpack中常见的Plugin</h2><p>Plugin是一种计算机应用程序 它和主应用程序互相交互 以提供特定的功能</p>
<p>是一种遵循一堆规范的应用程序接口编写出来的程序 只能运行在程序规定的系统下 因为其需要调用原纯净系统提供的函数库或数据</p>
<p>webpack中的plugin也是如此 plugin赋予其各种灵活的功能 例如打包优化 资源管理 环境变量注入等 它们会运行在webpack的不同阶段(钩子/生命周期) 贯穿了webpack整个编译周期</p>
<p>目的在于解决loader无法实现的其他功能</p>
<p>特性：</p>
<p>其本质是一个具有apply方法的js对象</p>
<p>apply方法会被webpack compiler调用 并且在整个编译生命周期都可以访问compiler对象</p>
<p>常用plugin<br>html-webpack-plugin<br>uglifyjs-webpack-plugin<br>mini-css-extract-plugin<br>optimize-css-assets-webpack-plugin</p>
<p>1.html-webpack-plugin<br>    html-webpack-plugin在官方文档中的解释是<br>    简化了 HTML 文件的创建，以便为你的 webpack 包提供服务。这对于那些文件名中包含哈希值，并且哈希值会    随着每次编译而改变的 webpack 包特别有用。你可以让该插件为你生成一个 HTML 文件，使用 lodash 模板提    供模板，或者使用你自己的 loader。<br>    我来解释一下这段话,用通俗的话来说,就是这个plugin是为了生成html文件的,而且会自动引入所依赖的打包好的    js代码,这些js代码在生成哈希值为了避免缓存的同时造成的问题就是html内的引入变得不再方便,因为没有规则    匹配来引入的话,那每次可能打包好的js都需要我们去手动引入,那么这个plugin就是为了解决这个问题的,引入所    需要的代码的意思就是不再会因为哈希值的改变而做另外的事情,plugin会帮我们找到这些js且帮我们引入到        html    </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;index_bundle.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>()],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由以上代码我们可以看到,其实这个plugin是一个不需要配置就能完成所做的事情的插件,生成的结果就是根据出口自动生成一个index.html文件,然后子啊index.html中去引入我们打包好的js文件</p>
<p>有的人肯定要想了,那我万一再html中写了代码,那我怎么办,我html中的代码这不是就被废弃掉了吗,其实不是的,我们的html可以当作模板传进去,这样生成的html就会以我们传入的html为模板去插入去生成我们所需的html,我们下边来说一下可配置的参数</p>
<p>1.title<br>用来生成页面的 title 元素,如果在页面中有title的话,可以忽略这个配置</p>
<p>2.filename<br>输出的 HTML 文件名，不配置的话默认就是./index.html,配置的话可以配置目录,比如./app/index.html,这样就会在dist文件夹下创建一个app文件夹,然后在app文件夹下输出我们的html</p>
<p>3.template<br>重点来了,这个就是上边说的配模板文件的路径，我们可以配置我们输出的时候想要的模板路径,从而生成我们定制的模板,我看了一下这个的说明,可以配置很多种类的模板.字符串也可以,非常通用</p>
<p>4.inject<br>这个配置项是选配的,可以选择四个值分别是true | ‘head’ | ‘body’ | false,true是属于默认值，script标签位于html文件的body底部, body与true一致,我其实也没理解意义是啥,head是说明script标签位于html文件的head中,false是不插入生成的js文件,这个唯一用到的就是我们要生成一个单纯的html文件,业务场景暂时没发现</p>
<p>5.favicon<br>指定我们生成的html的icon</p>
<p>6.minify<br>这个参数实际上是html-minifier是否应用,是用来压缩的,如果不用就是false,如果用的话就传递html-minifier的参数,caseSensitive|collapseWhitespace|removeAttributeQuotes|removeComments这四个的作用就是:大小写是否敏感,去空格,去属性引用,去注释</p>
<p>7.hash<br>是否生成hash添加在引入文件地址的末尾，这个可以避免缓存带来的麻烦。默认为true。</p>
<p>8.cache<br>默认值是true,代表只在文件被更改时才会发出新的文件,配置为false的话会每次打包都生成新的文件,导致浪费</p>
<p>9.showErrors<br>是否在html里添加错误的信息,如果选择true,那就会把错误信息生成一个pre插入到html中</p>
<p>10.chunks<br>用来配置哪些模块是可以插入html中的,可以选择性的插入自己要插入的js,比如入口文件有三个但是我当前html只需要两个那就可以插入两个</p>
<p>11.chunksSortMode<br>跳过某些不插入,这个我好像用的也不多,因为这俩是冲突的好像,记得报错过一次,就是选择插入和选择剔除是冲突的</p>
<p>非常常用的一个插件,在我的观念里这个应该是避不开的,因为你总需要解决缓存问题.总要自动引入打包的js,如果我们写的是多页面的话,那我们就需要重复使用这个插件,来做到自己的html插入自己的js打包文件,从而达到多页各自不冲突的效果</p>
<p>2.uglifyjs-webpack-plugin<br>uglifyjs-webpack-plugin插件用来缩小（压缩优化）js文件，最低使用版本为:Node v6.9.0/Webpack v4.0.0,一般我们现在的项目都是可以不用操心这个的,毕竟这俩兼容版本已经很低了<br>这里需要先说一个东西,就是optimization,这个也是webpack的一个配置,作用就是优化,默认的话是uglifyjs-webpack-plugin(webpack自己的)来压缩打包,但是这个我们是可以配置的,用不同的压缩插件来进行自定义,minimizer就是配置我们自定义插件的地方,默认为true</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="attr">optimization</span>: &#123;</span><br><span class="line">	<span class="attr">minimizer</span>: [</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">UglifyJsPlugin</span>()</span><br><span class="line">	]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这就是我们使用当前插件时候的默认配置,就可以修改为我们当前的插件来进行js的压缩,当然了也有很多的配置参数,我们来看一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">UglifyJsPlugin</span>(&#123;</span><br><span class="line">	<span class="attr">test</span>: <span class="regexp">/\.js(\?.*)?$/i</span>,  <span class="comment">//选中匹配规则文件,</span></span><br><span class="line">	<span class="attr">include</span>: <span class="regexp">/\/includes/</span>, <span class="comment">//包含哪些文件</span></span><br><span class="line">	<span class="attr">excluce</span>: <span class="regexp">/\/excludes/</span>, <span class="comment">//不包含哪些文件</span></span><br><span class="line">	<span class="comment">//看到filter我们就知道了吧这是个过滤器,用来过滤哪些压缩和不压缩的,返回true的是压缩的,返回false不压缩</span></span><br><span class="line">	<span class="attr">chunkFilter</span>: <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (chunk.<span class="property">name</span> === <span class="string">&#x27;天选之子&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> 	&#125;,</span><br><span class="line"> 	<span class="attr">cache</span>:<span class="literal">true</span>,<span class="comment">//是否缓存,可以写string模式的,来确定缓存路径</span></span><br><span class="line"> 	<span class="attr">parallel</span>:<span class="literal">true</span>,<span class="comment">//是否启动多线程提高构建速度,也可以写数字来确定几个线程,建议不用,一般来说没那么复杂用的话反而效果不好</span></span><br><span class="line"> 	<span class="attr">uglifyOptions</span>:&#123;&#125;<span class="comment">//这个可以写很多的具体压缩规则配置,因为默认用的是uglify-js,所以参数较多我下边列一下</span></span><br><span class="line"> &#125;),</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实话实说我建议用默认的就好,当然了解一下肯定是好的,比如混淆就是替换名称<br>可以直接看<a href="https://www.npmjs.com/package/uglify-js">uglify-js文档</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//parse 解释</span></span><br><span class="line"><span class="comment">//compress 压缩</span></span><br><span class="line"><span class="comment">//mangle 混淆</span></span><br><span class="line"><span class="comment">//beautify 美化</span></span><br><span class="line"><span class="comment">//minify 最小化</span></span><br><span class="line"><span class="comment">//CLI 命令行工具</span></span><br><span class="line"><span class="comment">//sourcemap 编译后代码对源码的映射，用于网页调试</span></span><br><span class="line"><span class="comment">//AST 抽象语法树</span></span><br><span class="line"><span class="comment">//name 名字，包括变量名、函数名、属性名</span></span><br><span class="line"><span class="comment">//toplevel 顶层作用域</span></span><br><span class="line"><span class="comment">//unreachable 不可达代码</span></span><br><span class="line"><span class="comment">//option 选项</span></span><br><span class="line"><span class="comment">//STDIN 标准输入，指在命令行中直接输入</span></span><br><span class="line"><span class="comment">//STDOUT 标准输出</span></span><br><span class="line"><span class="comment">//STDERR 标准错误输出</span></span><br><span class="line"><span class="comment">//side effects函数副作用，即函数除了返回外还产生别的作用，比如改了全局变量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个也是一个非常常用的插件,几乎可以算是做首选,因为官方文档上说的就是可以拿这个来自定义压缩,另外一个题外话就是optimization其实也有很多的参数可配置,在压缩文件的时候肯定是可以配置不同来选择自定义压缩方式的,可以看一下一个老大哥解释的很详细的optimization的帖子</p>
<p>3.mini-css-extract-plugin<br>我们前边已经梳理过了,在使用webpack构建工具的时候，通过style-loader，可以把解析出来的css通过js插入内部样式表的方式到页面中,我们如果不想这样做的话该怎么办,我们要做的是吧css都提出来,放在css文件中,这个然后用过我们第一个讲的html-webpack-plugin就可以默认引入我们随意变化哈希值的css文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">OptimizeCSSAssetsPlugin</span>(&#123;&#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;[name].css&quot;</span>,</span><br><span class="line">      <span class="attr">chunkFilename</span>: <span class="string">&quot;[id].css&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">          <span class="string">&quot;css-loader&quot;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看以上代码我们可以看出来,这个插件,算得上是简单好用,我们在做的事只是把style-loader换成MiniCssExtractPlugin.loader,我们用插件中的loader就可以取代style-loader的作用且打包的时候打包到css文件中,配置到minimizer中,说明我们这个也是可以用来做优化使用的,一般情况下我们会用const devMode = process.env.NODE_ENV !== ‘production’来拿到我们的当前环境,然后来判断是不是开发环境,如果是的话我们就会使用这个loder,如果不是的话我们可以使用style-loader</p>
<h5 id="4-optimize-css-assets-webpack-plugin"><a href="#4-optimize-css-assets-webpack-plugin" class="headerlink" title="4.optimize-css-assets-webpack-plugin"></a>4.optimize-css-assets-webpack-plugin</h5><ul>
<li><p>这个从名称上实际上可以看出端倪,这个就是一个用于优化css资源的插件。</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">类型</th>
<th align="center">默认值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">assetNameRegExp(可选)</td>
<td align="center">RegExp</td>
<td align="center">/.css$/g</td>
<td align="center">此插件压缩的对象是由<code>mini-css-extract-plugin</code>插件输出的css文件,而不是css源文件</td>
</tr>
<tr>
<td align="center">cssProcessor(可选)</td>
<td align="center">Function</td>
<td align="center"><a href="https://links.jianshu.com/go?to=https://github.com/cssnano/cssnano">cssnano</a></td>
<td align="center">压缩css的处理器,一个<code>函数</code>,接收<code>CSS模块和options参数</code>并返回一个<code>promise对象</code></td>
</tr>
<tr>
<td align="center">cssProcessorOptions(可选)</td>
<td align="center">Object</td>
<td align="center">{}</td>
<td align="center">传递给cssProcessor的配置对象</td>
</tr>
<tr>
<td align="center">cssProcessorPluginOptions(可选)</td>
<td align="center">Object</td>
<td align="center">{}</td>
<td align="center">传递给cssProcessor的插件配置对象</td>
</tr>
<tr>
<td align="center">canPrint(可选)</td>
<td align="center">Boolean</td>
<td align="center">true</td>
<td align="center">配置插件是否可以将消息打印到控制台</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">	<span class="attr">rules</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">			<span class="attr">loader</span>: <span class="title class_">ExtractTextPlugin</span>.<span class="title function_">extract</span>(<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">ExtractTextPlugin</span>(<span class="string">&#x27;styles.css&#x27;</span>),</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">OptimizeCssAssetsPlugin</span>(&#123;</span><br><span class="line">		<span class="attr">assetNameRegExp</span>: <span class="regexp">/\.optimize\.css$/g</span>,</span><br><span class="line">		<span class="attr">cssProcessor</span>: <span class="built_in">require</span>(<span class="string">&#x27;cssnano&#x27;</span>),<span class="comment">//引入cssnano配置参数</span></span><br><span class="line">		<span class="attr">cssProcessorPluginOptions</span>: &#123;</span><br><span class="line">			<span class="attr">preset</span>: [<span class="string">&#x27;default&#x27;</span>, &#123; <span class="attr">discardComments</span>: &#123; <span class="attr">removeAll</span>: <span class="literal">true</span> &#125; &#125;],</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">canPrint</span>: <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以看出来这个插件的使用方式与其他插件使用方式有所不同,我们需要传入我们前边所需要的插件,这样插件会生成我们需要的压缩css的loader,来进行css的压缩,且我们下边配置的ipction我们也都可以通过上边的参数表来对应查看,进行不同的配置,就不再一个个说明了</p>
<p>总结:今天我们就简单说这四个,都很常用,其实常用的plugin有很多,且比loader配置要多很多的可能性,因为插件本来就比loader作用更加的广泛,所以很难一次性的梳理很多,慢慢来,等plugin梳理完毕我们自己搭建一个满足我们所需功能的webpack打包,用来总结一下</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>严格模式是什么意思</title>
    <url>/2019/03/10/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</url>
    <content><![CDATA[<h2 id="严格模式是什么意思"><a href="#严格模式是什么意思" class="headerlink" title="严格模式是什么意思"></a>严格模式是什么意思</h2><p>use strict 严格模式是一种在js代码运行时自动实行更严格解析和错误处理的方法 这    种模式使得js在更严格的模式下运行 严格模式下不能使用未声明的变量</p>
<p>消除js语法的一些不合理不严谨之处 减少一些怪异行为</p>
<p>消除代码运行的一些不安全之处 保证代码运行的安全</p>
<p>提高编译器效率 增加运行速度</p>
<p>为未来新版本的js做好铺垫</p>
<p>缺点：<br>        网站的js都会进行压缩 一些文件用了严格模式 另一些没有用 这时这些本来是严        格模式的文件 merge之后 这个串就到了文件的中间 不仅没有指示严格模式 反        而在压缩后浪费字节</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中常见的Loader</title>
    <url>/2019/04/06/webpack%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84Loader/</url>
    <content><![CDATA[<h2 id="webpack中常见的Loader"><a href="#webpack中常见的Loader" class="headerlink" title="webpack中常见的Loader"></a>webpack中常见的Loader</h2><p>Loader用于对模块的源代码进行转换 在import或加载模块时预处理文件</p>
<p>webpack做的事情 仅仅是分析出各种模块的依赖关系 然后形成资源列表 最终打包生成到指定的文件中</p>
<p>在webpack内部中 任何文件都是模块 不仅仅只是js文件</p>
<p>默认情况下 遇到import或require加载模块的时候 webpack只支持对js和json文件打包</p>
<p>像css sass png等类型的文件时 webpack无能为力 这时就需要配置对应的loader进行文件内容解析</p>
<p>当webpack碰到不识别的模块的时候 webpack会在配置中查找该文件解析规则</p>
<p>关于配置loader方式有三种：<br>配置方式(推荐)：在webpack.config.js文件中指定loader</p>
<p>内联方式：在每个import语句中显式指定loader</p>
<p>CLI方式：在shell命令中指定</p>
<p>配置方式：<br>关于loader的配置 我们写在module.rules属性中 属性介绍：</p>
<p>rules是一个数组的形式 因此我们可以配置多个loader</p>
<p>每一个loader对应一个对象的形式  对象属性test为匹配的规则 一般情况为正则表达式</p>
<p>属性use针对匹配到文件类型 调用对应的loader进行处理</p>
<p>loader特性：<br>loader可以是同步的 也可以是异步的</p>
<p>loader运行在node中 并且能够执行任何操作</p>
<p>除了常见的通过package.json的main将一个npm模块导出为loader 还可以在module.rules中使用loader字段直接引用一个模块</p>
<p>插件可以为loader带来更多特性</p>
<p>loader能够产生额外的任意文件</p>
<p>可以通过loader的预处理函数 为js生态系统提供更多能力 用户现在可以更加灵活的引入细粒度逻辑</p>
<p>常见的loader:</p>
<p>在页面开发过程中 经常性加载除了js文件以外的内容 这时我们就需要配置相应的loader进行加载</p>
<p>style-loader 将css添加到DOM的内联样式标签style里</p>
<p>css-loader 允许将css文件通过require方式引入 并返回css代码</p>
<p>less-loader 处理less</p>
<p>sass-loader 处理sass</p>
<p>postcss-loader 用postcss处理css</p>
<p>autoprefixer-loader 处理css3属性前缀 已经被弃用 建议直接使用postcss</p>
<p>file-loader 分发文件到output目录并返回相对路径</p>
<p>url-loader 和file-loader类似 但是当文件小于设定的limit时可以返回一个Data Url</p>
<p>html-minify-loader 压缩HTML</p>
<p>babel-loader 用babel来转换ES6文件到ES</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>同步和异步的区别</title>
    <url>/2019/03/05/%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别"></a>同步和异步的区别</h2><p>同步：同步指一个进程在执行某个请求时 如果该请求需要一段时间才能返回信息 那么这个进程会一直等待下去 直到收到返回信息才继续执行</p>
<p>异步：异步指进程不需要一直等待 而是继续执行下面的操作 不管其他进程的状态 当有信息返回时就会通知进程进行处理 这样就可以提高执行的效率 异步是我们发出的请求 该请求会在后台自动发出并获取数据 然后对数据进行处理 在此过程中 我们可以继续做其他操作 不管他怎么发出请求 不关心怎么处理数据</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优化webpack打包速度</title>
    <url>/2019/04/03/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96webpack%E6%89%93%E5%8C%85%E9%80%9F%E5%BA%A6/</url>
    <content><![CDATA[<p>webpack打包优化分为两部分 一部分是大小优化 另一部分是速度优化</p>
<p>大小优化：</p>
<p>CommonsChunk</p>
<p>前端构建项目中 为了提高打包效率 往往将第三库与业务逻辑代码分开打包，因为第三方库往往不需要经常打包更新 webpack建议使用CommonsChunk单    独打包第三方库</p>
<p>CommonsChunk虽然可以减少包的大小 但存在问题是 即使代码不更新 每次重新打包 vendor都会重新生成 不符合我们分离第三方包的初衷</p>
<p>Externals</p>
<p>相比于CommonsChunk webpack提供Externals的方法 可以通过外部引用的方法 引入第三方库</p>
<p>DLL &amp; DllReference</p>
<p>相比于前者 通过前置这些依赖包的构建 来提高真正的build和rebuild构建效率 也就是说只要第三方库没有变化 之后每次build都只需要去打包自己的业    务代码 解决Externals多次引用问题 webpack通过webpack.DllPlugin与    webpack.DllReferencePlugin两个内嵌插件实现此功能</p>
<p>webpack.DllPlugin选项:<br>        path:manifest.json文件输出路径 这个文件会用于后续业务代码打包</p>
<p>name:dll暴露的对象名 要跟output.library保持一致</p>
<p>context:解析包路径的上下文 这个要跟接下来配置的webpack.config.js一致</p>
<p>webpack.DllReferencePlugin选项中:</p>
<p>context:需要跟之前保持一致 这个用来知道webpack匹配manifest.json中库的路径</p>
<p>manifest:用来引入刚才输出的manifest.json文件</p>
<p>速度优化：</p>
<p>优化loader配置</p>
<p>1.缩小文件匹配范围(include/exclude)</p>
<p>通过排除node_modules下的文件 从而缩小了loader加载搜索范围 高概率命中文件</p>
<p>2.缓存loader执行结果(cacheDirectory)</p>
<p>cacheDirectory是loader的一个特性的选项 默认值是false 指定的目录将用来缓存loader的执行结果 减少webpack构建时Babel重新编译过程 如果设置一个空值或true 将使用默认的缓存目录 如果在任何根目录下都    没有找到node_modules目录 将会降级回退到操作系统默认的临时文件目录</p>
<p>resolve优化配置</p>
<p>1.优化模块查找路径 resolve.modules</p>
<p>webpack的resolve.modules配置模块库所在的位置 在js里出现import ‘vue’这样不是相对 也不是绝对路径的写法时 回去node_modules目录下    找 但是默认的配置 会采用向上递归搜索的方式去寻找 但通常项目目录    里只有一个node_modules 且是在项目根目录 为了减少搜索范围 可以    直接写明node_modules的全路径 同样 对于别名的配置 亦当如此    </p>
<p>2.resolve.alias 配置路径别名</p>
<p>创建import或require的路径别名 来确保模块引入变得更简单 配置项通过别名来把原导入路径映射成一个新的导入路径 此优化方法会影响使用    Tree-Shaking去除无效代码</p>
<p>3.resolve.extensions</p>
<p>当引入模块时不带文件后缀webpack会根据此配置自动解析确定的文件后缀</p>
<p>后缀列表尽可能小</p>
<p>频率最高的往前放</p>
<p>导出语句尽可能带上后缀</p>
<p>module.noParse</p>
<p>用了noParse的模块将不会被loaders解析 所以当我们使用的库如果太大 并且其中不包含import require.define的调用 我们就可以使用这项配置来提升性    能 让webpack忽略对部分没采用模块化的文件的递归解析处理</p>
<p>HappyPack</p>
<p>HappyPa    ck是让webpack对loader的执行过程 从单一进程形式扩展为多进程模式 也就是将任务分解给多个子进程去并发的执行 子进程处理完后再把结    果发送给主进程 从而加速代码构建 与DLL动态链接库结合来使用更佳</p>
<p>happypack提供的loader 是对文件实际匹配的处理loader 这里happypack提供的loader与plugin衔接匹配 则是通过id=happypack来完成</p>
<p>ParallelUglifyPlugin</p>
<p>这个插件可以帮助有很多入口点的项目加快构建速度 把对js文件的串行压缩变为开启多个子进程并行进行uglify</p>
<p>Tree Shaking</p>
<p>提出js中用不上的代码 依赖静态的es6模块化语法 例如通过import和export导入导出</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>如何解决跨域问题</title>
    <url>/2019/03/17/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h2><p>跨域指的是浏览器不能执行其他网站的脚本 它是由浏览器的同源策略造成的 是浏览    器施加的安全限制</p>
<p>浏览器执行js脚本时 会检查这个脚本属于哪个页面 如果不是同源页面 就不会被执行</p>
<p>如果一个网站请求访问另一个网站 对比主域名不同 就会被拒绝</p>
<p>但是某些情况下我们需要向后台的服务器请求数据 就不得不涉及跨域</p>
<p>方式1:跨域资源共享(cors)</p>
<p>浏览器将CORS请求分为两类：简单请求和预检请求</p>
<p>解决方式就是服务端在响应头中加入字段:Access-control-allow-origin:Origin  该    Origin就可以访问了 如果该字段值为”*” 那么所有Origin均可访问</p>
<p>方式2:jsonp</p>
<p>通常为了减轻web服务器的负载 我们把js css img等静态资源分离到另一台独立域    名的服务器上 在html页面中再通过相应的标签从不同域名下加载静态资源 而被    浏览器允许 基于此原理 我们可以通过动态创建script 再请求一个带参网址实现    跨域通信</p>
<p>Web页面上调用js文件不受是否跨域的影响(凡是拥有src这个属性的标签都拥有    跨域的能力 <script>.<img>.<iframe>)</p>
<p>于是可以判断 当前阶段如果想通过纯web端跨域访问数据就只有一种可能 那就    是在远程服务器上设法把数据装进js格式的文件里 供客户端调用近一步处理</p>
<p>方式3:vue中设置代理服务器</p>
<p>跨域问题只存在浏览器 如果是服务器和服务器之间的通信不存在跨域问题</p>
<p>可以在vue-cli中设计代理服务器实现跨域请求</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>对promise的了解</title>
    <url>/2019/05/05/%E5%AF%B9promise%E7%9A%84%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="对promise的理解"><a href="#对promise的理解" class="headerlink" title="对promise的理解"></a>对promise的理解</h2><p>promise是异步编程的一种解决方案 相比于传统的解决方案-回调函数和事件更合理更强大 由社区最早提出实现 ES6将其写进了语言标准 统一语法 原生提供了promise</p>
<p>promise简单说就是一个容器 里面保存这某个未来才会结束的事件(异步操作)的结果 从语法上说 promise是一个对象 从它可以获取异步操作的消息 promise对象的状态不受外界影响</p>
<p>内部有三种状态：<br>        初始状态(pending)</p>
<p>已完成(resolve) resolve方法可以使promise对象状态改变为成功</p>
<p>已拒绝(reject) reject方法则是将promise对象状态改变为失败</p>
<p>常用的方法：</p>
<p>then 表示异步成功执行后的数据状态变为resolve</p>
<p>catch表示异步失败后执行的数据状态变为reject</p>
<p>all返回一个新的promise 只有所有的promise都成功才成功 只要有一个失败就直接失败</p>
<p>race 返回一个新的promise 第一个完成的promise结果状态就是最终的结果状态</p>
<p>在哪里使用过：</p>
<p>Ajax异步请求</p>
<p>函数嵌套层级多的时候用promise 优点在于回调函数变成链式写法 程序流程可以看得很清楚 而且有一整套配套方法 可以实现许多强大的功能</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>对webpack的看法 打包原理</title>
    <url>/2019/04/02/%E5%AF%B9webpack%E7%9A%84%E7%9C%8B%E6%B3%95/</url>
    <content><![CDATA[<h2 id="对webpack的看法-打包原理"><a href="#对webpack的看法-打包原理" class="headerlink" title="对webpack的看法 打包原理"></a>对webpack的看法 打包原理</h2><p>Webpack最初的目标是实现前端项目模块化 旨在更高效的管理和维护项目中的每一个资源</p>
<p>模块化：</p>
<p>最早的时候 我们通过文件划分的形式实现模块化 就是将每个功能及其相关状态    数据各自单独放到不同的js文件中 约定每个文件是独立的模块 然后再将这些js文件引入到页面 一个script标签对应一个模块 然后调用模块化的成员</p>
<p>这种模块弊端十分明显 模块都在全局中工作 大量模块成员污染了环境 模块与模块之间并没有依赖关系 难以维护 没有私有空间 </p>
<p>随后 就出现了命名空间方式 规定每个模块只暴露一个全局对象 然后模块的内容都挂载到对象中 这种方式也并没有解决依赖等问题</p>
<p>再后来 使用立即执行函数为模块提供私有空间 通过参数形式作为依赖声明</p>
<p>Webpack是一个用于现代js应用程序的静态模块打包工具</p>
<p>静态模块指的是开发阶段 可以被webpack直接引用的资源</p>
<p>当webpack处理应用程序是 它会在内部构建一个依赖图 此依赖图对应映射到项目所需的每个模块 并生成一个或多个bundle</p>
<p>Webpack能力：</p>
<p>编译代码能力 提高效率 解决浏览器兼容问题</p>
<p>模块整合能力 提高性能 可维护性 解决浏览器频繁请求文件的问题</p>
<p>万物皆可模块能力 项目维护性增强 支持不同种类的前端模块类型 统一的模块化方案 所有资源文件加载都可以通过代码控制</p>
<p>webpack打包原理是根据文件件的依赖关系对其进行静态分析 将这些模块按指定规则生成静态资源 当webpack处理程序时 它会递归地构建一个依赖关系图 其中包含应用程序需要的每个模块 将所有这些模块打包成一个或多个bundle</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>箭头函数与普通函数的区别</title>
    <url>/2019/03/07/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h2><p>1外形不同 箭头函数使用箭头定义 普通函数没有箭头</p>
<p>2 箭头函数全都是匿名函数 普通函数可以有匿名函数 也可以有具名函数</p>
<p>3 箭头函数不能用于构造函数 普通函数可以用于构造函数 以此创建对象实例</p>
<p>4 箭头函数中的this指向不同 在普通函数中 this指向调用它的对象 如果用作构造函    数 指向创建的对象实例 箭头函数获取当前函数上下文使用</p>
<p>5 箭头函数不具有arguments对象 每一个普通函数调用后都具有一个arguments对象     用来存储实际传递的参数 但是箭头函数并没有此对象</p>
<p>6 其他区别 箭头函数不具有 prototype原型对象 箭头函数不具有super new.target</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3新特征</title>
    <url>/2018/10/15/CSS3%E6%96%B0%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<p>圆角（border-radius）<br>阴影（box-shadow）<br>文字特效(text-shadow)<br>线性渐变（gradient）<br>变换(transform)<br>更多的CSS选择器<br>更多背景设置（background）<br>色彩模式（rgba）<br>伪元素（::selection）<br>媒体查询（@media）<br>多栏布局（column）<br>图片边框（border-image）</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>伪类和伪元素的区别</title>
    <url>/2018/10/21/%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h2><pre><code>### 伪类：
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/cb244f221003440ea81110e61684c696.png" alt="图片"></p>
<h3 id="伪元素："><a href="#伪元素：" class="headerlink" title="伪元素："></a>伪元素：</h3><p><img src="https://img-blog.csdnimg.cn/0905ecc76f554ccca9ab57dc6412c854.png" alt="图片"></p>
<p><strong>区别</strong></p>
<ul>
<li>伪类只能使用“<strong>：</strong>”，伪元素既可以使用“:”，也可以使用“::”</li>
<li>伪元素其实相当于伪造了一个元素，伪类没有伪造元素，例如first-child只是给子元素添加样式而已。（本质区别就是<strong>是否抽象创造了新元素</strong>）</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie与sessionStorage和localStorage的区别</title>
    <url>/2019/01/11/cookie%E4%B8%8EsessionStorage%E5%92%8ClocalStorage%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="cookie与sessionStorage和localStorage的区别"><a href="#cookie与sessionStorage和localStorage的区别" class="headerlink" title="cookie与sessionStorage和localStorage的区别"></a>cookie与sessionStorage和<a href="https://so.csdn.net/so/search?q=localStorage&spm=1001.2101.3001.7020">localStorage</a>的区别</h2><p>保存方式<br>cookie存放在客户的浏览器上。<br>session都在客户端中保存，不参与服务器通讯。</p>
<p>生命周期<br>cookie可设置失效时间<br>localStorage除非手动清除否则永久保存<br>sessionStorage关闭当前页面或浏览器后失效</p>
<p>存储的大小<br>cookie 4kb左右<br>session 5M</p>
<p>易用性<br>cookie需自己封装<br>session可以接受原生接口</p>
<p>因为cookie每次请求都会携带在http请求中,所以它的主要用来识别用户登录,localStorage可以用来跨页面传参,sessionStorage可以用来保留一些临时数据。</p>
<p>关于storage使用的方式可以查看storage传值</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>css怎么清除浮动</title>
    <url>/2018/10/11/css%E6%80%8E%E4%B9%88%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="css怎么清除浮动"><a href="#css怎么清除浮动" class="headerlink" title="css怎么清除浮动"></a>css怎么清除浮动</h2><p>父级div定义overflow:hidden（如果父级元素有定位元素超出父级，超出部分会隐藏，）<br>给浮动元素父级增加标签（由于新增标签会造成不必要的渲染，不建议使用）<br>伪元素清除浮动：给浮动元素父级增加 .clearfix::after（content: ‘’; display: table; clear: both;）（不会新增标签，不会有其他影响，）</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>重绘和重排是什么？如何避免？</title>
    <url>/2018/09/11/%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="重绘和重排是什么？如何避免？"><a href="#重绘和重排是什么？如何避免？" class="headerlink" title="重绘和重排是什么？如何避免？"></a>重绘和重排是什么？如何避免？</h2><p>重排：当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。<br>重绘：当一个元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，所以重绘跳过了创建布局树和分层的阶段。</p>
<p>重排需要重新计算布局树，重绘不需要，重排必定发生重绘，但是涉及到重绘不一定要重排 。涉及到重排对性能的消耗更多一些。</p>
<p>触发重排的方法： 页面初始渲染、添加/删除可见的DOM元素、改变元素位置、改变元素尺寸、改变元素内容、改变元素字体大小、改变浏览器窗口尺寸、设置 style 属性的值等。<br>避免重排的方式：样式集中改变、使用 absolute 或 fixed 脱离文档流。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>js实现继承的方法</title>
    <url>/2020/06/05/js%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="js实现继承的方法"><a href="#js实现继承的方法" class="headerlink" title="js实现继承的方法"></a>js实现继承的方法</h2><p>1.原型链继承</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br></pre></td></tr></table></figure>

<p>​    该方法与属性集中可复用的部分迁移到原型链中 而将不可复用的部分设置为对象自身的属性</p>
<p>2.仅从原型继承</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>=  <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>

<p>​    不存在原型链 所有的对象共享一个原型对象</p>
<p>​    优点：<br>​        1.由于该模式在构建继承关系时不需要新建对象实例 效率上会有较好的表现</p>
<p>​        2.原型链上的查询也会比较快 因为这里根本不存在链</p>
<p>​    缺点：</p>
<p>​        对子对象的修改会影响父对象</p>
<p> 3.临时构造器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">extend</span>(<span class="params">Child, Parent</span>) &#123;</span><br><span class="line">       <span class="keyword">var</span> A = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">       A.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Parent</span>. prototype;</span><br><span class="line">    <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">    <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>. constructor = <span class="title class_">Child</span>;</span><br><span class="line">    <span class="title class_">Child</span>.<span class="property">uber</span> = <span class="title class_">Parent</span>. prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    只继承父对象的原型属性 而对于其自身属性则不予继承</p>
<p>​    可以通过uber属性便捷访问父对象</p>
<p> 4.原型属性复制</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">extend</span>(<span class="params">Child, Parent</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="title class_">Parent</span>. prototype;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="title class_">Child</span>. <span class="title class_">Prototype</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">       c[i] = p[i];</span><br><span class="line">    &#125;     </span><br><span class="line">    c.<span class="property">uber</span> = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 5.浅复制</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">extendCopy</span>(<span class="params">p</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> c = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">       c[i] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="property">uber</span> = p;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    非常简单  没有使用原型属性</p>
<p> 6.深复刻</p>
<p>​    实现代码同上，只需在遇到对象类型时重复调用上述函数即可</p>
<p>​    效果与方法5基本相同，但复制的是对象和数组</p>
<p> 7.原型继承</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    直接在对象之间构建继承关系</p>
<p>​    发挥原型的固有优势</p>
<p> 8.扩展与增强模式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">objectPlus</span>(<span class="params">o, stuff</span>) &#123;</span><br><span class="line">     <span class="keyword">var</span> n;</span><br><span class="line">     <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">     F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">     n = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">     n.<span class="property">uber</span> = o;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> stuff) &#123;</span><br><span class="line">       n[i] = stuff[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> n; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p> 9.多重继承</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">multi</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">var</span> n = &#123;&#125;, stuff, j = <span class="number">0</span>,</span><br><span class="line">     len = <span class="variable language_">arguments</span>. length;</span><br><span class="line">     <span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; len; j++) &#123;</span><br><span class="line">       stuff = <span class="variable language_">arguments</span>[j];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> stuff) &#123;</span><br><span class="line">            n[i] = stuff[i];</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> n; </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>​    一种混合插入式的继承实现 会按照父对象的出现顺序依次对它们执行属性全复制</p>
<p> 10.寄生式继承</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parasite</span> (victim) &#123;</span><br><span class="line">    <span class="keyword">var</span> that = object (victim);</span><br><span class="line">    that.<span class="property">more</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> that;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>该方法通过一个类似于构造器的函数来创建对象</li>
<li>该函数会执行相应的对象复制，并对其进行扩展，然后返回该复制</li>
</ul>
<p> 11.构造器借用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>可以只继承父对象的自身属性</li>
<li>可以与方法1结合使用，以便从原型中继承相关内容</li>
<li>便于子对象在继承某个对象的具体属性（并且还有可能是引用类属性）时，选择最简单的处理方式</li>
</ul>
<p> 12.构造器借用与属性复制法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="title class_">Parent</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">extend2</span>(<span class="title class_">Child</span>, <span class="title class_">Parent</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>此方法是方法11与方法4的结合</li>
<li>它允许我们在不重复调用父对象构造器的情况下同时继承其自身属性和原型属性</li>
</ul>
<h3 id="如何选用继承方法？"><a href="#如何选用继承方法？" class="headerlink" title="如何选用继承方法？"></a>如何选用继承方法？</h3><p>​    取决于我们的设计风格、性能需求、具体项目任务及团队。</p>
<ul>
<li>习惯于从类的角度来解决问题？那么基于构造器的工作模式更合适</li>
<li>只关心该“类”的某些具体实例，则使用基于对象的工作模式更合适。</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket的理解</title>
    <url>/2020/05/12/websocket%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="websocket的理解"><a href="#websocket的理解" class="headerlink" title="websocket的理解"></a>websocket的理解</h2><h3 id="一，什么是websocket"><a href="#一，什么是websocket" class="headerlink" title="一，什么是websocket"></a>一，什么是websocket</h3><ul>
<li>WebSocket是HTML5下一种新的协议（websocket协议本质上是一个基于tcp的协议）</li>
<li>它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的</li>
<li>Websocket是一个<strong>持久化</strong>的协议</li>
</ul>
<h3 id="二，websocket的原理"><a href="#二，websocket的原理" class="headerlink" title="二，websocket的原理"></a>二，websocket的原理</h3><p>1.websocket约定了一个通信的规范，通过一个握手的机制，客户端和服务器之间能建立一个类似tcp的连接，从而方便它们之间的通信<br>2.在websocket出现之前，web交互一般是基于http协议的短连接或者长连接<br>3.websocket是一种全新的协议，不属于http无状态协议，协议名为”ws”</p>
<h3 id="三，websocket与http的关系"><a href="#三，websocket与http的关系" class="headerlink" title="三，websocket与http的关系"></a>三，websocket与http的关系</h3><p><img src="https://img-blog.csdnimg.cn/45259e81df6b4455bdcfcad460a3a8bf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAb2hhbmHvvIE=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图片"></p>
<p><strong>相同点：</strong></p>
<ol>
<li><strong>都是基于tcp的，都是可靠性传输协议</strong></li>
<li><strong>都是应用层协议</strong></li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li><strong>WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息</strong></li>
<li><strong>HTTP是单向的</strong></li>
<li><strong>WebSocket是需要浏览器和服务器握手进行建立连接的</strong></li>
<li><strong>而http是浏览器发起向服务器的连接，服务器预先并不知道这个连接</strong></li>
</ol>
<p> <strong>联系：</strong></p>
<ul>
<li><strong>WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的</strong></li>
</ul>
<p><strong>总结（总体过程）：</strong></p>
<p><strong>1.首先，客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等；</strong><br><strong>2.然后，服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据；</strong><br><strong>3.最后，客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。</strong></p>
<h3 id="四，websocket解决的问题"><a href="#四，websocket解决的问题" class="headerlink" title="四，websocket解决的问题"></a>四，websocket解决的问题</h3><p><strong>1.http存在的问题</strong><br>    <strong>http是一种无状态协议，每当一次会话完成后，服务端都不知道下一次的客户端是谁，需要每次知道对方是谁，才进行相应的响应，因此本身对于实时通讯就是一种极大的障碍</strong><br>    <strong>http协议采用一次请求，一次响应，每次请求和响应就携带有大量的header头，对于实时通讯来说，解析请求头也是需要一定的时间，因此，效率也更低下</strong><br>    <strong>最重要的是，需要客户端主动发，服务端被动发，也就是一次请求，一次响应，不能实现主动发送</strong><br><strong>2.long poll(长轮询)</strong><br>    <strong>对于以上情况就出现了http解决的第一个方法——长轮询</strong><br>    <strong>基于http的特性，简单点说，就是客户端发起长轮询，如果服务端的数据没有发生变更，会 hold 住请求，直到服务端的数据发生变化，或者等待一定时间超时才会返回。返回后，客户端又会立即再次发起下一次长轮询</strong><br>    <strong>优点是解决了http不能实时更新的弊端，因为这个时间很短，发起请求即处理请求返回响应，实现了“伪·长连接”</strong><br>    <strong>张三取快递的例子，张三今天一定要取到快递，他就一直站在快递点，等待快递一到，立马取走</strong></p>
<p>​    <strong>从例子上来看有个问题：</strong></p>
<ol>
<li>​    <strong>假如有好多人一起在快递站等快递，那么这个地方是否足够大，（抽象解释：需要有很高的并发，同时有很多请求等待在这里）</strong></li>
</ol>
<ul>
<li>总的来看：</li>
<li>推送延迟。服务端数据发生变更后，长轮询结束，立刻返回响应给客户端。</li>
<li>服务端压力。长轮询的间隔期一般很长，例如 30s、60s，并且服务端 hold 住连接不会消耗太多服务端资源。</li>
</ul>
<p><strong>3.Ajax轮询</strong></p>
<p>​    基于http的特性，简单点说，就是规定每隔一段时间就由客户端发起一次请求，查询有没有新消息，如果有，    就返回，如果没有等待相同的时间间隔再次询问</p>
<p>​    优点是解决了http不能实时更新的弊端，因为这个时间很短，发起请求即处理请求返回响应，把这个过程放大n    倍，本质上还是request = response<br>​    举个形象的例子（假设张三今天有个快递快到了，但是张三忍耐不住，就每隔十分钟给快递员或者快递站打电    话，询问快递到了没，每次快递员就说还没到，等到下午张三的快递到了，but，快递员不知道哪个电话是张三    的，（可不是只有张三打电话，还有李四，王五），所以只能等张三打电话，才能通知他，你的快递到了）</p>
<p>​     从例子上来看有两个问题：</p>
<p>​    假如说，张三打电话的时间间隔为10分钟，当他收到快递前最后一次打电话，快递员说没到，他刚挂掉电话，    快递入库了（就是到了），那么等下一次时间到了，张三打电话知道快递到了，那么这样的通讯算不算实时通    讯？很显然，不算，中间有十分钟的时间差，还不算给快递员打电话的等待时间（抽象的解释：每次request的    请求时间间隔等同于十分钟，请求解析相当于等待）<br>​    假如说张三所在的小区每天要收很多快递，每个人都采取主动给快递员打电话的方式，那么快递员需要以多快    的速度接到，其他人打电话占线也是问题（抽象解释：请求过多，服务端响应也会变慢）</p>
<ul>
<li>总的来看，Ajax轮询存在的问题：</li>
</ul>
<ol>
<li>推送延迟。</li>
<li>服务端压力。配置一般不会发生变化，频繁的轮询会给服务端造成很大的压力。</li>
<li>推送延迟和服务端压力无法中和。降低轮询的间隔，延迟降低，压力增加；增加轮询的间隔，压力降低，延迟增高</li>
</ol>
<p><strong>4.websocket的改进</strong></p>
<p>一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实现了“真·长链接”，实时性优势明显。</p>
<p><img src="https://img-blog.csdnimg.cn/b4f3c4efafd24359be26dc3166569f76.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAb2hhbmHvvIE=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图片"></p>
<p>WebSocket有以下特点：</p>
<p>是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。而HTTP长连接基于HTTP，是传统的客户端对服务器发起请求的模式。<br>HTTP长连接中，每次数据交换除了真正的数据部分外，服务器和客户端还要大量交换HTTP header，信息交换效率很低。Websocket协议通过第一个request建立了TCP连接之后，之后交换的数据都不需要发送 HTTP header就能交换数据，这显然和原有的HTTP协议有区别所以它需要对服务器和客户端都进行升级才能实现（主流浏览器都已支持HTML5）</p>
]]></content>
      <categories>
        <category>websocket</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
</search>
