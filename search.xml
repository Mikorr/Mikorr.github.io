<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTML是什么</title>
    <url>/2018/09/04/test/</url>
    <content><![CDATA[<h2 id="HTML是什么"><a href="#HTML是什么" class="headerlink" title="HTML是什么"></a>HTML是什么</h2><p>HTML指的是超文本标记语言 是制作超级文本文档的简单标记语言 可以从一个平台移    植到另一个平台 通常用于制作网页 html文件时asci文本 包括格式标记和超级文本链    的嵌入代码</p>
<p>HTMLtext是由HTML命令组成的描述性文本 他能够描述文字 图形 动画 声音 表格     连接等 网页结构由标题和正文两部分组成 Header描述浏览器需要的信息 并且主体    包含要描述的具体内容</p>
<p>Html是网页设计的基础。在网站结构中，静态网页被称为基于 HTML的网页。过去的网页都是直接用 HTML代码编写的，但现在有许多智能网页制作软件(经常使用的 frontpage、 dream weaver等)通常都是通过这些软件自动生成的，而不是手工编写。虽然不一定要自己写，但是理解 HTML代码还是很重要的。了解 HTML是什么？了解网站建设的重要技术基础知识。</p>
<h2 id="浏览器内核-常见的浏览器内核"><a href="#浏览器内核-常见的浏览器内核" class="headerlink" title="浏览器内核 常见的浏览器内核"></a>浏览器内核 常见的浏览器内核</h2><p>浏览器内核主要分为两部分：渲染引擎和JS引擎</p>
<p>渲染引擎：负责去的网页的内容(HTML、XML、图像等等) 整理讯息(例如加入css等) 以              及计算网页的思显示方式 然后会输出至服务器或打印机 浏览器的内核的              不同对于网页的语法解释会有不同 所以渲染的结果也不相同 所有网页浏              览器 电子邮件客户端以及其他需要编辑 显示网络内容的应用程序都需要              内核</p>
<p>JS引擎：解析和执行js来实现网页的动态效果</p>
<p>最开始渲染引擎和js引擎并没有区分的很明确 后来JS引擎越来越独立 内核就倾向于    只指渲染引擎</p>
<p>常见的浏览器内核：</p>
<p>IE浏览器内核:Trident内核 也是俗称的IE内核</p>
<p>Chrome浏览器内核:统称为Chromium内核或Chrome内核 以前是Webkit内核 现                      在是Blink内核</p>
<p>Firefox浏览器内核:Gecko内核 统称Firefox内核</p>
<p>Safari浏览器内核:Webkit内核</p>
<p>Opera浏览器内核:最初是自己的Presto内核 后来是Webkit 现在是Blink内核</p>
<p>360浏览器 猎豹浏览器内核:IE+Chrome双内核</p>
<p>搜狗 遨游 QQ浏览器内核:Trident+Webkit</p>
<p>百度浏览器内核:IE内核</p>
<p>2345浏览器内核:以前是IE内核 现在是IE+Chrome双内核</p>
<h2 id="如何理解HTML语义化"><a href="#如何理解HTML语义化" class="headerlink" title="如何理解HTML语义化"></a>如何理解HTML语义化</h2><p>用正确的标签做正确的事情</p>
<p>HTML语义化就是让页面的内容结构化 便于对浏览器 搜索引擎解析</p>
<p>在没有样式css情况下也以一种文档格式显示 并且是容易阅读的</p>
<p>搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重 利于SEO</p>
<p>使阅读源代码的人对网站更容易将网站分块 便于阅读维护理解</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>块标签 行内标签 行内块标签 区别？ 常见的标签？</title>
    <url>/2018/09/04/block/</url>
    <content><![CDATA[<p>行内标签 inline 又叫内联标签：<br>特点：不独占一行 每个行标签元素并排排序 直到遇到父级边界换行<br>不支持宽高 内容文本撑开宽高 不支持上下外边距 但支持左右外边距<br>会不正常显示上下内边距 不建议设置内边距<br>行内标签通常用于配合p标签实现富文本 富文本是指在一行文字中 文字形式不    统一<br>常见行内标签:</p>
<p>&lt;a&gt; &lt;span&gt;&lt;i&gt; &lt;b&gt; &lt;sub&gt; &lt;sup&gt; &lt;em&gt; &lt;strong&gt;&lt;br&gt;<br>块标签：<br>特点：独占一行 默认宽度占满父级 默认高度为0 子级内容撑开高度<br>常见块标签</p>
<p>&lt;h1-h6&gt;&lt;div&gt; &lt;p&gt; &lt;ul&gt; &lt;ol&gt;&lt;li&gt;&lt;dl&gt;&lt;dd&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;hr&gt; &lt;article&gt;<br>行内块标签：<br>特点：不独占一行 可以设置宽高<br>常见行内块标签：</p>
<p>&lt;img&gt; &lt;input&gt; &lt;textarea&gt; &lt;select&gt; &lt;option&gt;</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的浏览器内核</title>
    <url>/2018/09/05/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<h2 id="浏览器内核-常见的浏览器内核"><a href="#浏览器内核-常见的浏览器内核" class="headerlink" title="浏览器内核 常见的浏览器内核"></a>浏览器内核 常见的浏览器内核</h2><p>浏览器内核主要分为两部分：渲染引擎和JS引擎</p>
<p>渲染引擎：负责去的网页的内容(HTML、XML、图像等等) 整理讯息(例如加入css等) 以              及计算网页的思显示方式 然后会输出至服务器或打印机 浏览器的内核的              不同对于网页的语法解释会有不同 所以渲染的结果也不相同 所有网页浏              览器 电子邮件客户端以及其他需要编辑 显示网络内容的应用程序都需要              内核</p>
<p>JS引擎：解析和执行js来实现网页的动态效果</p>
<p>最开始渲染引擎和js引擎并没有区分的很明确 后来JS引擎越来越独立 内核就倾向于    只指渲染引擎</p>
<p>常见的浏览器内核：</p>
<p>IE浏览器内核:Trident内核 也是俗称的IE内核</p>
<p>Chrome浏览器内核:统称为Chromium内核或Chrome内核 以前是Webkit内核 现                      在是Blink内核</p>
<p>Firefox浏览器内核:Gecko内核 统称Firefox内核</p>
<p>Safari浏览器内核:Webkit内核</p>
<p>Opera浏览器内核:最初是自己的Presto内核 后来是Webkit 现在是Blink内核</p>
<p>360浏览器 猎豹浏览器内核:IE+Chrome双内核</p>
<p>搜狗 遨游 QQ浏览器内核:Trident+Webkit</p>
<p>百度浏览器内核:IE内核</p>
<p>2345浏览器内核:以前是IE内核 现在是IE+Chrome双内核</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5有哪些新特性 移除了哪些元素？</title>
    <url>/2018/09/05/%E7%A7%BB%E9%99%A4%E4%BA%86%E5%93%AA%E4%BA%9B%E5%85%83%E7%B4%A0%EF%BC%9F/</url>
    <content><![CDATA[<p>HTML现在已经不是SGML的子集 主要是关于图像 位置 存储 多任务等功能的增加</p>
<p>新增选择器document.querySelector document.querySelectorAll</p>
<p>拖拽播放(Drag and drop) API</p>
<p>媒体播放的video和audio</p>
<p>本地存储localStorage和sessionStorage</p>
<p>离线应用manifest</p>
<p>桌面通知Notifications</p>
<p>语义化标签article footer header nav section</p>
<p>增强表单控件 calendar date time email url search</p>
<p>地理位置 Geolocation</p>
<p>多任务 webworker</p>
<p>全双工通信协议 websocket</p>
<p>历史管理 history</p>
<p>跨域资源共享(CORS) Access-Control-Allow-Origin</p>
<p>页面可见性改变事件 visibilitychange</p>
<p>跨窗口通信 PostMessage</p>
<p>Form Data对象</p>
<p>绘画 canvas</p>
<p>移除的元素：</p>
<p>纯表现的元素：basefont big center font s strike tt u</p>
<p>对可见性产生负面影响的元素 frame frameset noframes</p>
<p>支持HTML5新标签：</p>
<p>IE8/IE7/IE6支持通过document.createElement方法产生的标签</p>
<p>可以利用这一特性让这些浏览器支持HTML5新标签</p>
<p>浏览器支持新标签后 还需要添加标签默认的样式</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用的命令有哪些</title>
    <url>/2018/10/13/Git%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B/</url>
    <content><![CDATA[<h2 id="Git常用的命令有哪些？"><a href="#Git常用的命令有哪些？" class="headerlink" title="Git常用的命令有哪些？"></a>Git常用的命令有哪些？</h2><p>git config –global user.name “用户名” </p>
<p>git config –global user.email “登录邮箱”</p>
<p>git clone url 下载一个项目和整个代码历史</p>
<p>git init 初始化仓库 默认master分支</p>
<p>git add . 提交全部文件修改到暂存区</p>
<p>git diff 查看当前代码add后 会add哪些内容</p>
<p>git status 查看当前分支状态</p>
<p>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt; 拉取远程仓库的分支与本地当前分支合并</p>
<p>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 拉取远程仓库的分支与本地某                                                 个分支和合并</p>
<p>git commit -m “&lt;注释&gt;” 提交代码到本地仓库 并写提交注释</p>
<p>git commit -v 提交时显示所有diff信息</p>
<p>git checkout &lt;分支名&gt; 切换到本地某个分支</p>
<p>git branch -D &lt;分支名&gt; 删除本地某个分支</p>
<p>git branch 查看本地所有分支</p>
<p>git branch -r 查看远程所有分支</p>
<p>git branch -a 查看本地和远程所有分支</p>
<p>git merge &lt;分支名&gt; 合并分支</p>
<p>git push [remote] [branch] 上传本地指定分支到远程仓库</p>
<p>git push [remote] –force 强行推送当前分支到远程仓库 即使有冲突</p>
<p>git checkout [file] 恢复暂存区的指定文件到工作区</p>
<p>git checkout . 恢复暂存区的所有文件到工作区</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>对git的理解</title>
    <url>/2018/10/13/%E5%AF%B9git%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="对git的理解"><a href="#对git的理解" class="headerlink" title="对git的理解"></a>对git的理解</h2><p>git是一个分布式版本控制软件 最初目的是为更好的管理Linuv内核开发而设计</p>
<p>分布式版本控制系统的客户端并不止提取最新版本的文件快照 而是把代码仓库完整的    镜像下来</p>
<p>GitHub或者gitee实际就可以充当服务器角色 其是一个开源协作社区</p>
<p>当我们通过git init 创建或者git clone一个项目时 项目目录会隐藏一个.git子目录 其作    用是用来跟踪管理版本库的</p>
<p>工作状态对应 不用状态文件在git中处于不同的工作区域 主要分成四部分:</p>
<p>工作区:相当于本地写代码的区域</p>
<p>暂存区:暂存区是一个文件 保存了下次将提交的文件列表信息 一般在git仓库目           录中</p>
<p>本地仓库:提交更新 找到暂存区域的文件 将快照永久性存储到Git本地仓库</p>
<p>远程仓库:远程的仓库 如GitHub gitee</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>浅拷贝和深拷贝的区别</title>
    <url>/2018/09/13/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="浅拷贝和深拷贝的区别"><a href="#浅拷贝和深拷贝的区别" class="headerlink" title="浅拷贝和深拷贝的区别"></a>浅拷贝和深拷贝的区别</h2><p>浅拷贝：主要是对指针的拷贝 拷贝后两个指针指向同一个内存空间 拷贝之后的数据修改之后 也会影响到原数据中的对象数据</p>
<p>深拷贝：将数据中所有的数据拷贝下来 对拷贝之后的数据进行修改不会影响到原数据</p>
<p>实现方式：</p>
<p>深拷贝：</p>
<p>1.使用递归实现</p>
<p>2.Json.stringify和Json.parse</p>
<p>用json.stringify把对象转换成字符串 再用Json.parse把字符串转换成新    的对象 可以转成Json格式的对象才能使用这种方法 如果对象中包含    function或RegExp就不能使用这种方法</p>
<ol>
<li>函数库lodash的_.cloneDeep方法</li>
</ol>
<p>var _ = require(‘loadsh’)</p>
<p>var obj = {</p>
<p>a:{</p>
<p>c:2,</p>
<p>d:[9,8,7]</p>
<p>},</p>
<p>b:4</p>
<p>}</p>
<p>var obj1 = _.cloneDeep(obj)</p>
<ol start="2">
<li>通过JQuery的extend方法实现深拷贝：</li>
</ol>
<p>var _ = require(‘jquery’)</p>
<p>var obj = {</p>
<p>a:{</p>
<p>c:2,</p>
<p>d:[9,8,7]</p>
<p>},</p>
<p>b:4</p>
<p>}</p>
<p>var obj1 = _.extend(true,{},obj)</p>
<p>浅拷贝：</p>
<ol>
<li>通过拷贝构造方法实现浅拷贝：</li>
</ol>
<p>拷贝构造方法指的是该类的构造方法参数为该类的对象 使用拷贝构造方    法可以很好地完成浅拷贝 直接通过一个现有的对象创建出与该对象属性    相同的新对象</p>
<ol start="2">
<li>通过重写clone()方法进行浅拷贝</li>
</ol>
<p>object类有一个方法为protected Object clone() throws     CloneNotSupportedException 这个方法就是进行的浅拷贝 有了这个浅拷    贝模板 可以通过调用clone()方法来实现对象的浅拷贝</p>
<p>​    注意：</p>
<p>​    object类虽然有这个方法 但是这个方法是受保护的 所以无法直接使用</p>
<p>​    使用clone方法的类必须实现Cloneable接口 否则会抛出异常    CloneNotSupportedException 解决方法是 在使    用clone方法的类中重写clone方法 通过super.clone()调用object类中的原clone方法</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>说说git发生冲突的场景</title>
    <url>/2018/10/14/%E8%AF%B4%E8%AF%B4git%E5%8F%91%E7%94%9F%E5%86%B2%E7%AA%81%E7%9A%84%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h2 id="说说git发生冲突的场景"><a href="#说说git发生冲突的场景" class="headerlink" title="说说git发生冲突的场景"></a>说说git发生冲突的场景</h2><p>情景一：多个分支代码合并到一个分支</p>
<p>情景二：多个分支向同一个远端分支推送代码时</p>
<p>push和pull其实就是分别用本地分支合并到远程分支和将远程分支合并到本地分支</p>
<p>所以这两个过程中也可能存在冲突</p>
<p>git的合并产生冲突的具体情况：</p>
<p>1 两个分支中修改了同一个文件</p>
<p>2 两个分支中修改了同一个文件的名称</p>
<p>两个分支中分别修改了不同文件中的部分 不会产生冲突 可以直接将两部分合并</p>
<p>解决方法：</p>
<p>情景一：在当前分支 直接修改冲突代码</p>
<p>情景二：在本地当前分支 修改冲突代码</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的数据类型 存储上的区别</title>
    <url>/2018/10/23/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="JavaScript中的数据类型-存储上的区别"><a href="#JavaScript中的数据类型-存储上的区别" class="headerlink" title="JavaScript中的数据类型 存储上的区别"></a>JavaScript中的数据类型 存储上的区别</h2><p>基本数据类型：</p>
<p>Number</p>
<p>String</p>
<p>Boolean</p>
<p>Undefined</p>
<p>Null</p>
<p>Symbol</p>
<p>引用数据类型：</p>
<p>Object</p>
<p>Array</p>
<p>Function</p>
<p>区别：</p>
<p>基本数据类型指的就是简单的数据段 引用数据类型指的是多个值构成的对象 当    我们把变量赋值给一个变量时 解析器首先要确认的就是这个值是基本数据类型还    是引用类型值</p>
<p>存储区别：</p>
<p>Js中的变量都是保存在栈内存中的 基本数据类型的值都是直接保存在栈内存中     值与值之间是独立的存在 因此当修改一个变量的值不会影响其他变量的值</p>
<p>对象是保存在堆内存中的 每创建一个对象 就会在堆内存中开辟出一个新的空间     变量保存的是对象的内存地址（对象的应用） 保存的并不是值 如果两个变量保存    的是同一个地址 当通过一个变量修改属性时 另一个也会受影响</p>
<p>比较两个基本数据类型的值时 比较的就是值 比较两个引用数据类型时 比较的是内存地址 如果两个对象一模一样但是内存地址不同 也会返回false</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>对闭包的理解</title>
    <url>/2018/11/01/%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="对闭包的理解"><a href="#对闭包的理解" class="headerlink" title="对闭包的理解"></a>对闭包的理解</h2><p>闭包就是能够读取其他函数内部变量的函数</p>
<p>闭包指有权访问另一个函数作用域中变量的函数 创建闭包最常见的方式就是在一个函    数内创建另一个函数 通过另一个函数访问这个函数的局部变量</p>
<p>闭包特性：</p>
<p>函数套函数</p>
<p>内部函数可以引用外部函数的参数和变量</p>
<p>不会被垃圾回收机制回收    </p>
<p>使用闭包主要是为了设计私有方法和变量 闭包的优点是可以避免全局变量污染 缺点    是闭包会常驻内存 增大内存使用量 使用不当容易造成内存泄漏 在js中 函数即闭包</p>
<p>闭包最大的用处 一是可以读取函数内部变量 二是让这些变量始终保持在内存中 延长    变量生命周期</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是模块化</title>
    <url>/2018/10/21/%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h2><p>模块化指解决一个复杂问题时 自顶向下逐层把系统划分成若干模块的过程 对于整体    系统来说 模块是可组合 分解和更换的单元</p>
<p>一个js文件中可以引入另一个js文件的数据</p>
<p>模块化的好处：</p>
<p>提高了代码的复用性</p>
<p>提高了代码的可维护性</p>
<p>可以实现按需加载</p>
<p>模块化的规范：</p>
<p>每个模块内部 module变量代表当前模块</p>
<p>module变量是一个对象 他的exports是对外的接口</p>
<p>加载某个模块 其实是加载该模块的module.exports属性 .require()方法常用于加载    模块</p>
<p>在自定义模块中定义的变量和方法 只能在当前模块被访问 外部文件不可访问 这种模    块级别的访问限制 叫做模块作用域 他防止了全局变量污染 文件依赖等问题</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>typeof与instanceof区别</title>
    <url>/2018/11/04/typeof%E4%B8%8Einstanceof%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="typeof和instanceof的区别"><a href="#typeof和instanceof的区别" class="headerlink" title="typeof和instanceof的区别"></a>typeof和instanceof的区别</h2><p>typeof操作符返回一个字符串 表示未经计算的操作数的类型</p>
<p>null在typeof之后返回的是有问题的结果 不能作为判断null的方法 判断null array object和函数实例 都是返回object 引用数据类型    使用typeof判断 除了function可以被识别 其余都输出object</p>
<p>instanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型    链上 </p>
<p>区别：</p>
<p>typeof返回一个变量基本类型 instanceof返回一个布尔值</p>
<p>instanceof可以准确判断复杂引用数据类型  但不能正确判断基础数据类型</p>
<p>typeof虽然可以判断基础数据类型 但是引用数据类型中 除了function类型 其他    的也无法判断    </p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>css选择器</title>
    <url>/2018/10/02/css%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器"></a>css选择器</h2><p>css选择器是css规则的一部分  是元素和其他部分组合起来告诉浏览器哪个html元素应当是被选为应用规则中的css属性值的方式 选择器所选择的元素 叫做选择器的对象</p>
<p>Css选择器常用的有：</p>
<p>Id选择器(#box) 选择id为box的元素</p>
<p>类选择器(.box) 选择类名为box的所有元素</p>
<p>标签选择器(div) 选择标签为div的所有元素</p>
<p>后代选择器(#box div) 选择id为box元素内部所有div元素</p>
<p>子选择器(.box&gt;box_1) 选择父元素类名为box内所有类名为box_1的元素</p>
<p>相邻同胞选择器(.one+.two) 选择紧接在.one之后的所有.two元素</p>
<p>群组选择器(div,p) 选择所有div p元素</p>
<p>还有一些使用频率相对没那么多的选择器:</p>
<p>伪类选择器:</p>
<p>:link:选择未被访问的链接</p>
<p>:visited:选择已被访问的链接</p>
<p>:active:选择活动链接</p>
<p>:hover:鼠标指针浮动在上面的元素</p>
<p>:focus:算则具有焦点的</p>
<p>:first-child:父元素的首个子元素</p>
<p>伪元素选择器:</p>
<p>:first-letter:用于选区制定选择器的首字母</p>
<p>:first-line:选取指定选择器的首行</p>
<p>:before:选择器在被选元素的内容前面插入内容</p>
<p>:after:选择器在被选元素的内容后面插入内容</p>
<p>属性选择器:</p>
<p>[attribute] 选择带有attribute属性的元素</p>
<p>[attribute=value] 选择所有使用attribute=value的元素</p>
<p>[attribute~=value] 选择attribute属性包含value的元素</p>
<p>[attribute|=value] 选择attribute属性以value开头的元素</p>
<p>在css3中新增的选择器有：</p>
<p>层次选择器(p~ul) 选择前面有p元素的每个ul元素</p>
<p>伪类选择器:</p>
<p>:first-of-type 父元素的首个元素</p>
<p>:last-of-type 父元素的最后一个元素</p>
<p>:only-of-type 父元素的特定类型的唯一子元素</p>
<p>:only-child 父元素中唯一子元素</p>
<p>:nth-child(n) 选择父元素中第N个子元素</p>
<p>:nth-last-of-type(n) 选择父元素中第N个子元素，从后往前</p>
<p>:last-child 父元素的最后一个元素</p>
<p>:root 设置HTML文档</p>
<p>:empty 指定空的元素</p>
<p>:enabled 选择被禁用元素</p>
<p>:disabled 选择被禁用元素</p>
<p>:checked 选择选中的元素</p>
<p>:not(selector) 选择非 <selector> 元素的所有元素</p>
<p>属性选择器:</p>
<p>[attribute*=value] :选择attribute属性值包含value的所有元素</p>
<p>优先级：内联样式&gt;ID选择器&gt;类选择器&gt;标签选择器</p>
<p>继承属性：</p>
<p>在css中 继承指的是给父元素设置一些属性 后代元素会自动拥有这些属性</p>
<p>继承属性可以分成：</p>
<p>字体系列属性:</p>
<p>font:组合字体</p>
<p>font-family:规定元素的字体系列</p>
<p>font-weight:设置字体的粗细</p>
<p>font-size:设置字体的尺寸</p>
<p>font-style:定义字体的风格</p>
<p>font-variant:偏大或偏小字体</p>
<p>文本系列属性:</p>
<p>Text-indent:文本缩进</p>
<p>Text-align:文本水平</p>
<p>Line-height:行高</p>
<p>word-spacing:增加或减少单词间的空白</p>
<p>letter-spacing:增加或减少字符间的空白</p>
<p>text-transform:控制文本大小写</p>
<p>direction:规定文本的书写方向</p>
<p>color:文本颜色</p>
<p>元素可见性:</p>
<p>visibility</p>
<p>表格布局属性:</p>
<p>caption-side:定义表格标题位置</p>
<p>border-collapse:合并表格边框</p>
<p>border-spacing:设置相邻单元格的边框间的距离</p>
<p>empty-cells:单元格的边框出现与消失</p>
<p>table-layout:表格的宽度由什么决定</p>
<p>列表属性:</p>
<p>list-style-type:文字前面的小点样式</p>
<p>list-style-position:小点位置</p>
<p>list-style:以上的属性可通过属性集合</p>
<p>引用:</p>
<p>quotes:设置嵌套引用的引号类型</p>
<p>光标属性:</p>
<p>cursor:箭头可以变成需要的形状</p>
<p>继承中比较特殊的几点:</p>
<p>h1-h6标签字体的大小也是不能被继承的</p>
<p>a标签字体颜色不能被继承</p>
]]></content>
      <categories>
        <category>HTML</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>对盒子模型的理解</title>
    <url>/2018/10/02/%E5%AF%B9%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="对盒子模型的理解"><a href="#对盒子模型的理解" class="headerlink" title="对盒子模型的理解"></a>对盒子模型的理解</h2><p>在浏览网站时 我们会发现页面内容都是按照区域划分的 在页面中每一块区域分别承    载不同的内容 使网页内容虽然零散 但是在版式排列上依然清晰有条理 承载内容的区    域被称为盒子模型</p>
<p>盒子模型分为两种：</p>
<p>\1. 标准盒模型：content(内容)+margin(外边距)+padding(内边距)+border(边框)</p>
<p>\2. IE盒模型(怪异盒模型):content+margin</p>
<p>标准盒模型下的宽：盒子总宽度/高度=width/height+padding+border+margin 这种模    型下 写得元素往往会必设置的宽高要多出一部分padding border margin</p>
<p>IE盒模型下的宽:盒子总宽度和高度是包含内边距padding和变宽border宽度在内    的盒子总宽度/高度 = width/height+margin=内容区宽度/高度    +padding+border+margin 也就是说width = 内容区宽度+padding+border</p>
<p>我们在开发中往往使用IE盒模型 只需要设置box-sizing:border-box即可</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>元素水平垂直居中的方法</title>
    <url>/2018/10/05/%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="元素水平垂直居中的方法"><a href="#元素水平垂直居中的方法" class="headerlink" title="元素水平垂直居中的方法"></a>元素水平垂直居中的方法</h2><p>利用定位+margin:auto  </p>
<p>父级设置为相对定位 子级绝对定位 并且四个定位属性值都为0 如果子级没    有设置宽高 则会被拉开到和父级一样宽高 设置了宽高所以宽高会按照设置    来显示 实际上子级虚拟占位已经撑满了整个父级 再给他一个margin:auto就    可以垂直居中了</p>
<p>利用定位+margin:负值 </p>
<p>这种方案不要求父元素的高度 即使父元素的高度变化了 仍然可以保持在父    元素的垂直居中位置 水平方向上操作一样  但是该方案需要知道子元素自身    宽高</p>
<p>利用定位+transform</p>
<p>translate(-50%,-50%)将会将元素位移自己宽度和高度的-50%</p>
<p>这种方法其实和最上面被否定掉的margin负值用法一样 可以说是margin负    值的替代方案 并不需要知道自身元素的宽高</p>
<p>table布局</p>
<p>设置父元素为display:table-cell 子元素设置display:inline-block 利用vertical和    text-align可以让所有的行内块级元素水平垂直居中</p>
<p>flex布局</p>
<p>display:flex时 表示该容器内部的元素按照flex进行布局</p>
<p>Align-items:center表示这些元素将相对于本容器水平居中</p>
<p>justify-content:conter也是同样的道理垂直居中</p>
<p>grid布局</p>
<p>父级设置grid align-items:center justify-content:center 和flex相同</p>
<p>不知道元素宽高大小仍能实现水平居中的方法有：</p>
<p>利用定位+margin:auto</p>
<p>利用定位+transform</p>
<p>利用定位+margin:负值</p>
<p>flex布局</p>
<p>grid布局</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS提高性能的方法</title>
    <url>/2018/10/06/CSS%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>加载性能：</p>
<ol>
<li>css压缩：</li>
</ol>
<p>将写好的css进行打包 可以减少很多的体积</p>
<ol start="2">
<li>css单一样式：</li>
</ol>
<p>在需要下边距和左边距的时候 很多时候选择：margin:top 0 bottom 0 但是margin-bottom:bottom margin-left:left执行效率更高</p>
<ol start="3">
<li>减少@import建议使用link：</li>
</ol>
<p>因为link在页面加载时一起加载  @import是等待页面加载完成之后再进行加载</p>
<p>选择器性能：</p>
<p>​    1. 关键选择器：</p>
<p>选择器的最后面的部分为关键选择器 css选择器是从右向左进行匹配的 当使用后代选择器的时候 浏览器会遍历所有子元素来确定是否是指定的元素等等</p>
<p>​    2. 如果规则拥有ID选择器作为关键选择器：</p>
<p>不要为规则增加标签 过滤掉无关规则</p>
<p>​    3. 避免使用通配符规则：</p>
<p>如果*{} 计算次数太多 只对需要用到的元素进行选择</p>
<p>​    4. 尽量少的对标签选择 使用class</p>
<p>​    5. 了解哪些属性可以通过继承而来 避免对这些属性重复指定规则</p>
<p>渲染性能：</p>
<p>​    1. 慎重使用高性能属性：浮动 定位</p>
<p>​    2. 尽量减少页面的重排和重绘</p>
<p>​    3. 去除空规则,{}空规则的产生的原因一般是为了预留样式 去除空规则能减少css文档体积</p>
<p>​    4. 属性值为0时 不加单位</p>
<p>​    5. 属性值为浮动小数 可以省略小数点之前的0</p>
<p>​    6. 标准化各种浏览器前缀 带浏览器前缀的在前 标准属性在后</p>
<p>​    7. 不使用@import前缀 因为它会影响css的加载速度</p>
<p>​    8. 选择器优先嵌套 尽量避免层级过深</p>
<p>​    9. css雪碧图：</p>
<p>​        同一页面相近部分的小图标 方便实用 减少页面请求次数</p>
<ol start="10">
<li>正确使用display属性 由于display的使用 某一些样式组合会无效 徒增样式体积的同时也影响性能</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>事件循环</title>
    <url>/2018/11/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>Js是一门单线程的语言 同一时间内只能做一件事 每次只能执行一项任务 其他任务都得按照顺序排队等待被执行 只有当前任务执行完成之后才会执行下一个任务  任务分为同步任务和异步任务 异步任务永远在同步任务执行完成后才执行</p>
<p>注意：异步函数在响应辅助线程中处理完成后 即异步函数达到触发条件了 就把回调函数推入任务队列中 而不是说注册一个异步任务就会被放在任务队列中</p>
<p>主线程不断从任务队列中读取事件  这个过程是循环不断的 这种运行机制就叫做事件循环</p>
<p>事件循环中的两种任务：</p>
<p>在js中 除了广义的同步任务和异步任务 异步任务还可以细分 一种是宏任务(MacroTask) 一种是微任务(MicroTask)</p>
<p>每次单个宏任务执行完毕后 检查微任务队列是否为空 如果不为空 会按照先入先出的规则全部执行完微任务后 清空微任务队列 然后再执行下一个宏任务 依次循环</p>
<p>如何区分微任务 宏任务？</p>
<p>宏任务：macrotask可以理解为每次执行栈执行的代码就是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行) 一般包括script setTimeout     setInterval setImmediate IO操作</p>
<p>微任务：microtask 又称为job 可以理解是当前task执行结束后立即执行的任务 包括promise then cath finally回调 mutationObserver回调</p>
<p>为什么异步要区分宏任务与微任务？</p>
<p>因为事件队列其实是一个先进先出的数据结构 排在前面的事件会优先被主线程读取 如果突然来了一个优先级更高的任务 还排队就很不理性化 所以需要引入微任务</p>
<p>在当前微任务没有执行完成时 不会执行下一次宏任务的</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>响应式设计</title>
    <url>/2018/10/05/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>响应式设计是一种网络页面设计布局 页面的设计与开发应当根据用户行为以及设备环境(系统平台.屏幕尺寸.屏幕定向等)进行相应的响应和调整</p>
<p>响应式网站常见特点：同时适配PC+平板+手机等</p>
<p>标签导航在接近手持终端设备时改变为经典的抽屉式导航</p>
<p>网站的布局会根据视口来调整模块的大小和位置</p>
<p>实现方式：响应式设计的基本原理就是通过媒体查询检测不同设备屏幕尺寸做处理为了处理移动端 页面头部必须有meta声明viewport</p>
<p>&lt;meta name=”viewport” content=”width=device-width, initial-scale=1,     maximum-scale=1, user-scalable=no”&gt;</p>
<p>属性对应：</p>
<p>width=device-width:自适应手机屏幕的尺寸宽度</p>
<p>maximum-scale:缩放比例的最大值</p>
<p>Inital-scale:缩放的初始化</p>
<p>User-scalable:用户可以缩放的操作</p>
<p>实现响应式布局的方式：</p>
<p>媒体查询</p>
<p>Css3中增加了更多的媒体查询 就像if条件表达式一样 可以设置不同类型的媒体条件 并根据对应的条件给响应符合条件的媒体调用相对应的样    式表 使用@Media查询 可以针对不同的媒体类型定义不同的样式</p>
<p>当重置浏览器大小的过程中 页面也会根据浏览器的宽度和高度重新渲染页面</p>
<p>语法规范：</p>
<p>@media mediatype and|not|only (media feature){</p>
<p>css-code;</p>
<p>}</p>
<p>用@media开通</p>
<p>mediatype媒体类型</p>
<p>关键字and not only</p>
<p>media feature 媒体特性 必须有小括号包含</p>
<p>mediatype查询类型：将不同的终端设备划分为不同类型 称为媒体类型</p>
<table>
<thead>
<tr>
<th>值</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>用于所有设备</td>
</tr>
<tr>
<td>print</td>
<td>用于打印机和打印预览</td>
</tr>
<tr>
<td>scree</td>
<td>用于电脑屏幕 平板电脑 智能手机等</td>
</tr>
</tbody></table>
<p>关键字：将媒体类型或多个特性连接到一起作为媒体查询的条件</p>
<p>and:可以将多个媒体特性连接到一起 相当于且的意思</p>
<p>not:排除某个媒体类型 相当于非的意思 可以省略</p>
<p>only:指定某个特定的媒体类型 可省略</p>
<p>媒体特性：每种媒体类型都具备各自不同的特性 根据不同媒体类型特性设置不同的展示风格</p>
<table>
<thead>
<tr>
<th>值</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>定义输出设备中页面可见区域的宽度</td>
</tr>
<tr>
<td>min-width</td>
<td>定义输出设备中页面最小可见区域的宽度</td>
</tr>
<tr>
<td>max-width</td>
<td>定义输出设备中页面最大可见区域的宽度</td>
</tr>
</tbody></table>
<p>百分比</p>
<p>通过百分比单位%来实现响应式的效果 比如当浏览器宽度或高度发生变    化时 通过百分比单位 可以使得浏览器中的组件的宽和高随着浏览器的    变化而变化 从而实现响应式的效果 不能设置字体大小</p>
<p>vw/vh</p>
<p>vw表示相对于视图窗口的宽度 vh表示相对于视图窗口高度 任一层级元    素 在使用vw单位的情况下 1vw等于视图宽度的百分之一 1vh等于视图    高度的百分之一 与百分比    布局很相似 与百分比不同的是可以设置字体    大小 缺点兼容性较差</p>
<p>rem </p>
<p>rem相对于根元素html的font-size属性 默认情况下浏览器字体大小为    16px 可以利用媒体查询 针对不同设备分辨率修改font-size的值</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>回流和重绘</title>
    <url>/2018/10/05/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/</url>
    <content><![CDATA[<h2 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h2><p>回流：在渲染树构建完成 进入layout的时候 首先根据渲染树的数据 计算出各个节点在屏幕上的位置 然后进入绘制阶段渲染树中的一部分或者全部因为元素的规模尺寸 布局和隐藏等改变需要重新构建 这过程称为回流 每个页面至少需要一次回流 就是页面第一次加载的时候</p>
<p>重绘：渲染树中的一些元素需要更新属性 而这些属性只是影响元素的外观 风格 而不影响布局 称之为重绘</p>
<p>回流必定会引起重绘 因为回流将导致渲染树重新构建 回流花销比重绘花销高</p>
<p>重绘不一定引起回流</p>
<p>回流触发时机：</p>
<p>回流在一阶段主要是计算节点位置和几何信息 当页面布局和几何信息发生变化的时候 就需要回流：</p>
<p>添加或删除可见dom元素</p>
<p>元素位置发生变化</p>
<p>元素尺寸发生变化(包括外边距 内边距 边框大小 高度宽度等)</p>
<p>内容发生变化 比如文本变化或图片被另一个不同尺寸图片所替代</p>
<p>页面一开始渲染的时候</p>
<p>浏览器的窗口尺寸变化</p>
<p>还有通过即时计算得到的属性 浏览器为了获取这些值 也会进行回流</p>
<p>重绘触发时机：</p>
<p>触发回流一定会触发重绘</p>
<p>颜色的修改  文本方向修改  阴影的修改都会引发重绘</p>
<p>浏览器优化机制</p>
<p>由于每次重排都造成额外的计算消耗 因此大多数浏览器都会通过队列化修改并批量执行优化重排过程 浏览器会将修改操作放入到队列里 直到过了一段时间或者操作达到了一个阈值 才清空队列</p>
<p>当获取布局信息的操作时 会强制队列刷新</p>
<p>因此浏览器不得不清空队列 触发回流重绘返回正确的值</p>
<p>如何减少回流重绘</p>
<p>如果想设定元素样式 通过改变元素class类名</p>
<p>避免设置多项内联样式</p>
<p>应用元素的动画 使用position属性的fixed值或者absolute值</p>
<p>避免使用table布局 table每个元素大小以及内容改动会导致整个table重新计算</p>
<p>对于复杂的动画 对其设置position:fixed/absolute 尽可能使元素脱离文档流 从而减少对其他元素的影响</p>
<p>使用css3硬件加速 可以让transform opacity filters动画不会引起回流重绘</p>
<p>避免使用css的js表达式</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>BOM的理解</title>
    <url>/2018/09/21/BOM%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="BOM的理解"><a href="#BOM的理解" class="headerlink" title="BOM的理解"></a>BOM的理解</h2><p>BOM是浏览器对象模型 就是和浏览器有关系的 作用就是跟浏览器做交互效果</p>
<p>比如如何进行页面前进后退刷新 窗口发生变化 滚动条的滚动</p>
<p>浏览器全部内容可以看成DOM 整个浏览器可以看成BOM</p>
<p>BOM包含DOM</p>
<p>常用的BOM对象：</p>
<p>BOM的核心是window 表示浏览器的一个实例</p>
<p>在浏览器中 window对象有双重角色 即是浏览器窗口的一个接口 又是全局对象</p>
<p>因此所有在全局作用域中声明的变量函数都会变成window对象的属性和方法</p>
<p>document对象：文档对象</p>
<p>location对象：浏览器当前url信息  只要修改location的属性 就会导致页面重新加载新的URL</p>
<p>location.reload()可以重新刷新当前页面 这个方法会根据最有效的方    式刷新页面 如果页面自上一次请求以来没有改变过 页面就会从浏    览器缓存中重新加载 如果要强制从服务器中重新加载 穿第一个参数true即可</p>
<p>navigator对象：浏览器本身信息 主要用来获取浏览器的属性 区分浏览器类型</p>
<p>screen对象：客户端屏幕信息 保存的是客户端能力信息 就是浏览器窗口外面的客户端显示器的信息 比如像素宽度高度</p>
<p>history对象：浏览器访问历史信息 主要用来操作浏览器URL的历史记录 可以通过参数向前向后或者指定URL跳转</p>
<p>history.go() 接受一个整数数字或者字符串 像最近的一个记录中包含指定字符串的页面跳转</p>
<p>参数为整数数字时 正数表示向前跳转指定页面 负数为向后跳转指定页面</p>
<p>history.forward()向前跳转一个页面</p>
<p>history.back()向后跳转一个页面</p>
<p>history.length 获取历史记录数</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>bind、call、apply区别</title>
    <url>/2018/11/05/bind%E3%80%81call%E3%80%81apply%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="bind、call、apply区别"><a href="#bind、call、apply区别" class="headerlink" title="bind、call、apply区别"></a>bind、call、apply区别</h2><p>call apply bind作用是改变函数执行时的上下文 简而言之就是改变函数运行时的this指向</p>
<p>call和apply都是对函数进行直接调用 改变this指向后原函数会立即执行 且此方法只是临时改变this指向一次</p>
<p>而bind方法改变this指向不会立即执行 而是返回一个永久改变this指向的函数</p>
<p>三者第一个参数都是this指向的对象 如果没有这个参数或者参数为undefined或null 则默认指向全局window</p>
<p>三者都可以传参 但是apply是数组 call是参数列表 apply和call是一次性传入 bind可以分为多次传入</p>
<p>bind返回绑定this之后的函数 apply call是立即执行</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM常见的操作</title>
    <url>/2018/09/14/DOM%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="DOM常见的操作"><a href="#DOM常见的操作" class="headerlink" title="DOM常见的操作"></a>DOM常见的操作</h2><p>DOM 文档对象模式是html和XML文档的编程接口</p>
<p>提供了对文档结构化的表述 并定义了一种方式可以使从程序中对该结构进行访问     从而改变文档的结构样式和内容 任何HTML或XML文档都可以用DOM表示为一    个由节点构成的层级结构</p>
<p>获取节点：</p>
<p>document.getElementById(id) 通过id获取元素 返回一个元素对象</p>
<p>document.getElementByName(name) 通过name属性获取id返回元素对象数组</p>
<p>document.getElementByClassName(className) 通过class获取元素 返回元素    对象数组</p>
<p>document.getElementByTagName(tagName)  通过标签名获取元素 返回元素    对象数组</p>
<p>document.querySelector()  es6标准 通过css选择器获取元素 返回第一个匹    配元素 没有指定的元素返回null</p>
<p>document.querySelectorAll() es6标准 通过css选择器获取元素 返回类数组集    合 没有相匹配的返回空节点列表</p>
<p>获取/设置元素的属性值:</p>
<p>element.getArrtibute(attributeName) 括号传入属性名 返回对应属性的属性值</p>
<p>Element.setAttribute(attributeName,attributeValue) 传入属性名及设置的值</p>
<p>创建节点node：</p>
<p>document.createElement() 创建一个html元素 参数为要创建的标签名</p>
<p>document.createTextNode(string) 创建一个文本节点</p>
<p>Document.createDocumentFragment() 创建一个文档碎片 表示一种轻量级的    文档 主要用来存储临时节点 然后把文档碎片内容一次性添加到DOM中</p>
<p>document.createAttribute(class) 创建一个属性节点 可以是自定义属性</p>
<p>增添节点:</p>
<p>element.innerHTML 如果这个DOM节点是空的 直接使用innerHTML就可以修    改DOM节点的内容 相当于添加新的DOM节点</p>
<p>element.appendChild(Node) 往element内部最后面添加一个节点 参数是节点    类型</p>
<p>element.insertBefore(newNode,existingNode) 把子节点插入existingNode之前 </p>
<p>element.setArrtibute(‘class’,’white’) 在指定元素中添加一个属性节点 如果元素已有该属性    改变属性值 第一个参数为属性名 第二个参数为属性值</p>
<p>删除节点:</p>
<p>Element.removeChild(Node) 删除当前节点下指定的子节点 删除成功返回被    删除的节点 否组返回null</p>
<p>Element.removeAttribute(new,old)</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
</search>
